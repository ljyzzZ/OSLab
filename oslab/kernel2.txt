
build/kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00101000 <abort>:
#include "klib.h"

int abort(const char *file, int line, const char *info) {
  101000:	55                   	push   %ebp
  101001:	89 e5                	mov    %esp,%ebp
  101003:	83 ec 08             	sub    $0x8,%esp
  101006:	8b 45 10             	mov    0x10(%ebp),%eax
static inline void outl(int port, uint32_t data) {
  asm volatile ("outl %%eax, %%dx" : : "a"(data), "d"((uint16_t)port));
}

static inline void cli() {
  asm volatile ("cli");
  101009:	fa                   	cli    
  cli();
  printf("Abort @ [%s:%d] %s\n", file, line, info ? info : "");
  10100a:	85 c0                	test   %eax,%eax
  10100c:	74 17                	je     101025 <abort+0x25>
  10100e:	50                   	push   %eax
  10100f:	ff 75 0c             	push   0xc(%ebp)
  101012:	ff 75 08             	push   0x8(%ebp)
  101015:	68 00 40 10 00       	push   $0x104000
  10101a:	e8 9d 01 00 00       	call   1011bc <printf>
  10101f:	83 c4 10             	add    $0x10,%esp
static inline void sti() {
  asm volatile ("sti");
}

static inline void hlt() {
  asm volatile ("hlt");
  101022:	f4                   	hlt    
  101023:	eb fd                	jmp    101022 <abort+0x22>
  101025:	b8 5e 42 10 00       	mov    $0x10425e,%eax
  10102a:	eb e2                	jmp    10100e <abort+0xe>

0010102c <list_remove_prev>:
  ptr->prev->next = ptr;
  ptr->next->prev = ptr;
}

static list_t *list_remove_prev(list_t *list) {
  assert(!list_empty(list));
  10102c:	3b 40 08             	cmp    0x8(%eax),%eax
  10102f:	74 13                	je     101044 <list_remove_prev+0x18>
  list_t *ptr = list->prev;
  101031:	8b 40 04             	mov    0x4(%eax),%eax
  ptr->prev->next = ptr->next;
  101034:	8b 48 04             	mov    0x4(%eax),%ecx
  101037:	8b 50 08             	mov    0x8(%eax),%edx
  10103a:	89 51 08             	mov    %edx,0x8(%ecx)
  ptr->next->prev = ptr->prev;
  10103d:	8b 48 04             	mov    0x4(%eax),%ecx
  101040:	89 4a 04             	mov    %ecx,0x4(%edx)
  return ptr;
}
  101043:	c3                   	ret    
static list_t *list_remove_prev(list_t *list) {
  101044:	55                   	push   %ebp
  101045:	89 e5                	mov    %esp,%ebp
  101047:	83 ec 0c             	sub    $0xc,%esp
  assert(!list_empty(list));
  10104a:	68 14 40 10 00       	push   $0x104014
  10104f:	6a 11                	push   $0x11
  101051:	68 26 40 10 00       	push   $0x104026
  101056:	e8 a5 ff ff ff       	call   101000 <abort>

0010105b <list_init>:
  for (int i = 0; i < LIST_NUM; ++i) {
    list_add_next(&free_list, &list_buf[i]);
  }
}

void list_init(list_t *list) {
  10105b:	55                   	push   %ebp
  10105c:	89 e5                	mov    %esp,%ebp
  10105e:	53                   	push   %ebx
  10105f:	83 ec 04             	sub    $0x4,%esp
  101062:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!inited) {
  101065:	83 3d 00 60 10 00 00 	cmpl   $0x0,0x106000
  10106c:	74 0b                	je     101079 <list_init+0x1e>
    inited = 1;
    init_list();
  }
  list->prev = list->next = list;
  10106e:	89 5b 08             	mov    %ebx,0x8(%ebx)
  101071:	89 5b 04             	mov    %ebx,0x4(%ebx)
}
  101074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101077:	c9                   	leave  
  101078:	c3                   	ret    
    inited = 1;
  101079:	c7 05 00 60 10 00 01 	movl   $0x1,0x106000
  101080:	00 00 00 
  list_init(&free_list);
  101083:	83 ec 0c             	sub    $0xc,%esp
  101086:	68 04 60 10 00       	push   $0x106004
  10108b:	e8 cb ff ff ff       	call   10105b <list_init>
  for (int i = 0; i < LIST_NUM; ++i) {
  101090:	b8 20 60 10 00       	mov    $0x106020,%eax
  101095:	b9 20 6c 10 00       	mov    $0x106c20,%ecx
  10109a:	83 c4 10             	add    $0x10,%esp
  ptr->prev = list;
  10109d:	c7 40 04 04 60 10 00 	movl   $0x106004,0x4(%eax)
  ptr->next = list->next;
  1010a4:	8b 15 0c 60 10 00    	mov    0x10600c,%edx
  1010aa:	89 50 08             	mov    %edx,0x8(%eax)
  ptr->prev->next = ptr;
  1010ad:	a3 0c 60 10 00       	mov    %eax,0x10600c
  ptr->next->prev = ptr;
  1010b2:	89 42 04             	mov    %eax,0x4(%edx)
  for (int i = 0; i < LIST_NUM; ++i) {
  1010b5:	83 c0 0c             	add    $0xc,%eax
  1010b8:	39 c8                	cmp    %ecx,%eax
  1010ba:	75 e1                	jne    10109d <list_init+0x42>
  1010bc:	eb b0                	jmp    10106e <list_init+0x13>

001010be <list_empty>:

int list_empty(list_t *list) {
  1010be:	55                   	push   %ebp
  1010bf:	89 e5                	mov    %esp,%ebp
  1010c1:	8b 45 08             	mov    0x8(%ebp),%eax
  return list == list->next;
  1010c4:	39 40 08             	cmp    %eax,0x8(%eax)
  1010c7:	0f 94 c0             	sete   %al
  1010ca:	0f b6 c0             	movzbl %al,%eax
}
  1010cd:	5d                   	pop    %ebp
  1010ce:	c3                   	ret    

001010cf <list_enqueue>:

list_t *list_enqueue(list_t *list, void *ptr) {
  1010cf:	55                   	push   %ebp
  1010d0:	89 e5                	mov    %esp,%ebp
  1010d2:	53                   	push   %ebx
  1010d3:	83 ec 04             	sub    $0x4,%esp
  1010d6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  list_t *l = list_remove_prev(&free_list);
  1010d9:	b8 04 60 10 00       	mov    $0x106004,%eax
  1010de:	e8 49 ff ff ff       	call   10102c <list_remove_prev>
  l->ptr = ptr;
  1010e3:	8b 55 0c             	mov    0xc(%ebp),%edx
  1010e6:	89 10                	mov    %edx,(%eax)
  ptr->prev = list;
  1010e8:	89 58 04             	mov    %ebx,0x4(%eax)
  ptr->next = list->next;
  1010eb:	8b 53 08             	mov    0x8(%ebx),%edx
  1010ee:	89 50 08             	mov    %edx,0x8(%eax)
  ptr->prev->next = ptr;
  1010f1:	89 43 08             	mov    %eax,0x8(%ebx)
  ptr->next->prev = ptr;
  1010f4:	8b 50 08             	mov    0x8(%eax),%edx
  1010f7:	89 42 04             	mov    %eax,0x4(%edx)
  list_add_next(list, l);
  return l;
}
  1010fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1010fd:	c9                   	leave  
  1010fe:	c3                   	ret    

001010ff <list_dequeue>:

void *list_dequeue(list_t *list) {
  1010ff:	55                   	push   %ebp
  101100:	89 e5                	mov    %esp,%ebp
  101102:	83 ec 08             	sub    $0x8,%esp
  101105:	8b 45 08             	mov    0x8(%ebp),%eax
  if (list_empty(list)) {
  101108:	3b 40 08             	cmp    0x8(%eax),%eax
  10110b:	74 26                	je     101133 <list_dequeue+0x34>
    return NULL;
  }
  list_t *l = list_remove_prev(list);
  10110d:	e8 1a ff ff ff       	call   10102c <list_remove_prev>
  void *ptr = l->ptr;
  101112:	8b 10                	mov    (%eax),%edx
  ptr->prev = list;
  101114:	c7 40 04 04 60 10 00 	movl   $0x106004,0x4(%eax)
  ptr->next = list->next;
  10111b:	8b 0d 0c 60 10 00    	mov    0x10600c,%ecx
  101121:	89 48 08             	mov    %ecx,0x8(%eax)
  ptr->prev->next = ptr;
  101124:	a3 0c 60 10 00       	mov    %eax,0x10600c
  ptr->next->prev = ptr;
  101129:	8b 48 08             	mov    0x8(%eax),%ecx
  10112c:	89 41 04             	mov    %eax,0x4(%ecx)
  list_add_next(&free_list, l);
  return ptr;
}
  10112f:	89 d0                	mov    %edx,%eax
  101131:	c9                   	leave  
  101132:	c3                   	ret    
    return NULL;
  101133:	ba 00 00 00 00       	mov    $0x0,%edx
  101138:	eb f5                	jmp    10112f <list_dequeue+0x30>

0010113a <list_remove>:

void list_remove(list_t *list, list_t *entry) {
  10113a:	55                   	push   %ebp
  10113b:	89 e5                	mov    %esp,%ebp
  10113d:	8b 45 0c             	mov    0xc(%ebp),%eax
  entry->next->prev = entry->prev;
  101140:	8b 48 08             	mov    0x8(%eax),%ecx
  101143:	8b 50 04             	mov    0x4(%eax),%edx
  101146:	89 51 04             	mov    %edx,0x4(%ecx)
  entry->prev->next = entry->next;
  101149:	8b 48 08             	mov    0x8(%eax),%ecx
  10114c:	89 4a 08             	mov    %ecx,0x8(%edx)
  ptr->prev = list;
  10114f:	c7 40 04 04 60 10 00 	movl   $0x106004,0x4(%eax)
  ptr->next = list->next;
  101156:	8b 15 0c 60 10 00    	mov    0x10600c,%edx
  10115c:	89 50 08             	mov    %edx,0x8(%eax)
  ptr->prev->next = ptr;
  10115f:	a3 0c 60 10 00       	mov    %eax,0x10600c
  ptr->next->prev = ptr;
  101164:	8b 50 08             	mov    0x8(%eax),%edx
  101167:	89 42 04             	mov    %eax,0x4(%edx)
  list_add_next(&free_list, entry);
}
  10116a:	5d                   	pop    %ebp
  10116b:	c3                   	ret    

0010116c <putstrn>:
#include "klib.h"
#include "serial.h"

void putstrn(const char *str, size_t count) {
  10116c:	55                   	push   %ebp
  10116d:	89 e5                	mov    %esp,%ebp
  10116f:	56                   	push   %esi
  101170:	53                   	push   %ebx
  101171:	8b 45 0c             	mov    0xc(%ebp),%eax
  for (int i = 0; i < count; ++i) {
  101174:	85 c0                	test   %eax,%eax
  101176:	74 1b                	je     101193 <putstrn+0x27>
  101178:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10117b:	01 d8                	add    %ebx,%eax
  10117d:	89 c6                	mov    %eax,%esi
    putchar(str[i]);
  10117f:	83 ec 0c             	sub    $0xc,%esp
  101182:	0f be 03             	movsbl (%ebx),%eax
  101185:	50                   	push   %eax
  101186:	e8 0b 0e 00 00       	call   101f96 <putchar>
  for (int i = 0; i < count; ++i) {
  10118b:	43                   	inc    %ebx
  10118c:	83 c4 10             	add    $0x10,%esp
  10118f:	39 f3                	cmp    %esi,%ebx
  101191:	75 ec                	jne    10117f <putstrn+0x13>
  }
}
  101193:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101196:	5b                   	pop    %ebx
  101197:	5e                   	pop    %esi
  101198:	5d                   	pop    %ebp
  101199:	c3                   	ret    

0010119a <putstr>:

void putstr(const char *str) {
  10119a:	55                   	push   %ebp
  10119b:	89 e5                	mov    %esp,%ebp
  10119d:	53                   	push   %ebx
  10119e:	83 ec 10             	sub    $0x10,%esp
  1011a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  putstrn(str, strlen(str));
  1011a4:	53                   	push   %ebx
  1011a5:	e8 be 26 00 00       	call   103868 <strlen>
  1011aa:	83 c4 08             	add    $0x8,%esp
  1011ad:	50                   	push   %eax
  1011ae:	53                   	push   %ebx
  1011af:	e8 b8 ff ff ff       	call   10116c <putstrn>
}
  1011b4:	83 c4 10             	add    $0x10,%esp
  1011b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1011ba:	c9                   	leave  
  1011bb:	c3                   	ret    

001011bc <printf>:

int printf(const char *format, ...) {
  1011bc:	55                   	push   %ebp
  1011bd:	89 e5                	mov    %esp,%ebp
  1011bf:	83 ec 0c             	sub    $0xc,%esp
  int r;
  va_list args;
  va_start(args, format);
  1011c2:	8d 45 0c             	lea    0xc(%ebp),%eax
  r = vcprintf(putstr, format, args);
  1011c5:	50                   	push   %eax
  1011c6:	ff 75 08             	push   0x8(%ebp)
  1011c9:	68 9a 11 10 00       	push   $0x10119a
  1011ce:	e8 c1 25 00 00       	call   103794 <vcprintf>
  va_end(args);
  return r;
}
  1011d3:	c9                   	leave  
  1011d4:	c3                   	ret    

001011d5 <ban_read>:
#include "serial.h"
#include "fs.h"

static int ban_read(void *buf, size_t count) {
  return -1;
}
  1011d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1011da:	c3                   	ret    

001011db <ignore_write>:

static int ignore_write(const void *buf, size_t count) {
  1011db:	55                   	push   %ebp
  1011dc:	89 e5                	mov    %esp,%ebp
  return count;
}
  1011de:	8b 45 0c             	mov    0xc(%ebp),%eax
  1011e1:	5d                   	pop    %ebp
  1011e2:	c3                   	ret    

001011e3 <init_dev>:
  {"/dev/null", {ban_read, ignore_write}}
};

#define DEV_NUM (sizeof(dev_table) / sizeof(dev_table[0]))

void init_dev() {
  1011e3:	55                   	push   %ebp
  1011e4:	89 e5                	mov    %esp,%ebp
  1011e6:	83 ec 10             	sub    $0x10,%esp
  iclose(iopen("/dev", TYPE_DIR)); // create the dev dir
  1011e9:	6a 02                	push   $0x2
  1011eb:	68 39 40 10 00       	push   $0x104039
  1011f0:	e8 a0 00 00 00       	call   101295 <iopen>
  1011f5:	89 04 24             	mov    %eax,(%esp)
  1011f8:	e8 d7 02 00 00       	call   1014d4 <iclose>
  for (int i = 0; i < DEV_NUM; ++i) {
    iadddev(dev_table[i].name, i);
  1011fd:	83 c4 08             	add    $0x8,%esp
  101200:	6a 00                	push   $0x0
  101202:	68 20 55 10 00       	push   $0x105520
  101207:	e8 cf 01 00 00       	call   1013db <iadddev>
  10120c:	83 c4 08             	add    $0x8,%esp
  10120f:	6a 01                	push   $0x1
  101211:	68 48 55 10 00       	push   $0x105548
  101216:	e8 c0 01 00 00       	call   1013db <iadddev>
  }
}
  10121b:	83 c4 10             	add    $0x10,%esp
  10121e:	c9                   	leave  
  10121f:	c3                   	ret    

00101220 <dev_get>:

dev_t *dev_get(int id) {
  101220:	55                   	push   %ebp
  101221:	89 e5                	mov    %esp,%ebp
  101223:	8b 45 08             	mov    0x8(%ebp),%eax
  if (id >= DEV_NUM) return NULL;
  101226:	83 f8 01             	cmp    $0x1,%eax
  101229:	77 0c                	ja     101237 <dev_get+0x17>
  return &dev_table[id].dev_op;
  10122b:	8d 04 80             	lea    (%eax,%eax,4),%eax
  10122e:	8d 04 c5 40 55 10 00 	lea    0x105540(,%eax,8),%eax
}
  101235:	5d                   	pop    %ebp
  101236:	c3                   	ret    
  if (id >= DEV_NUM) return NULL;
  101237:	b8 00 00 00 00       	mov    $0x0,%eax
  10123c:	eb f7                	jmp    101235 <dev_get+0x15>

0010123e <init_fs>:
  dinode_t dinode;
};

static inode_t inodes[MAX_INODE];

void init_fs() {
  10123e:	55                   	push   %ebp
  10123f:	89 e5                	mov    %esp,%ebp
  101241:	57                   	push   %edi
  101242:	56                   	push   %esi
  101243:	53                   	push   %ebx
  101244:	81 ec 14 02 00 00    	sub    $0x214,%esp
  dinode_t buf[MAX_FILE];
  read_disk(buf, 256);
  10124a:	68 00 01 00 00       	push   $0x100
  10124f:	8d 9d e8 fd ff ff    	lea    -0x218(%ebp),%ebx
  101255:	53                   	push   %ebx
  101256:	e8 0c 11 00 00       	call   102367 <read_disk>
  for (int i = 0; i < MAX_FILE; ++i) {
  10125b:	b8 20 6c 10 00       	mov    $0x106c20,%eax
  101260:	89 da                	mov    %ebx,%edx
  101262:	bb e0 6e 10 00       	mov    $0x106ee0,%ebx
  101267:	83 c4 10             	add    $0x10,%esp
    inodes[i].valid = 1;
  10126a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    inodes[i].type = TYPE_FILE;
  101270:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
    inodes[i].dinode = buf[i];
  101277:	8d 78 0c             	lea    0xc(%eax),%edi
  10127a:	b9 08 00 00 00       	mov    $0x8,%ecx
  10127f:	89 d6                	mov    %edx,%esi
  101281:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  for (int i = 0; i < MAX_FILE; ++i) {
  101283:	83 c0 2c             	add    $0x2c,%eax
  101286:	83 c2 20             	add    $0x20,%edx
  101289:	39 d8                	cmp    %ebx,%eax
  10128b:	75 dd                	jne    10126a <init_fs+0x2c>
  }
}
  10128d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101290:	5b                   	pop    %ebx
  101291:	5e                   	pop    %esi
  101292:	5f                   	pop    %edi
  101293:	5d                   	pop    %ebp
  101294:	c3                   	ret    

00101295 <iopen>:

inode_t *iopen(const char *path, int type) {
  101295:	55                   	push   %ebp
  101296:	89 e5                	mov    %esp,%ebp
  101298:	57                   	push   %edi
  101299:	56                   	push   %esi
  10129a:	53                   	push   %ebx
  10129b:	83 ec 0c             	sub    $0xc,%esp
  10129e:	8b 7d 08             	mov    0x8(%ebp),%edi
  for (int i = 0; i < MAX_INODE; ++i) {
  1012a1:	bb 34 6c 10 00       	mov    $0x106c34,%ebx
  1012a6:	be 00 00 00 00       	mov    $0x0,%esi
  1012ab:	eb 09                	jmp    1012b6 <iopen+0x21>
  1012ad:	46                   	inc    %esi
  1012ae:	83 c3 2c             	add    $0x2c,%ebx
  1012b1:	83 fe 20             	cmp    $0x20,%esi
  1012b4:	74 27                	je     1012dd <iopen+0x48>
    if (!inodes[i].valid) continue;
  1012b6:	83 7b ec 00          	cmpl   $0x0,-0x14(%ebx)
  1012ba:	74 f1                	je     1012ad <iopen+0x18>
    if (strcmp(path, inodes[i].dinode.name) == 0) {
  1012bc:	83 ec 08             	sub    $0x8,%esp
  1012bf:	53                   	push   %ebx
  1012c0:	57                   	push   %edi
  1012c1:	e8 13 25 00 00       	call   1037d9 <strcmp>
  1012c6:	83 c4 10             	add    $0x10,%esp
  1012c9:	85 c0                	test   %eax,%eax
  1012cb:	75 e0                	jne    1012ad <iopen+0x18>
      return &inodes[i];
  1012cd:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  1012d0:	01 c0                	add    %eax,%eax
  1012d2:	01 f0                	add    %esi,%eax
  1012d4:	8d 04 85 20 6c 10 00 	lea    0x106c20(,%eax,4),%eax
  1012db:	eb 05                	jmp    1012e2 <iopen+0x4d>
    }
  }
  return NULL;
  1012dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1012e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1012e5:	5b                   	pop    %ebx
  1012e6:	5e                   	pop    %esi
  1012e7:	5f                   	pop    %edi
  1012e8:	5d                   	pop    %ebp
  1012e9:	c3                   	ret    

001012ea <iread>:

int iread(inode_t *inode, uint32_t off, void *buf, uint32_t len) {
  1012ea:	55                   	push   %ebp
  1012eb:	89 e5                	mov    %esp,%ebp
  1012ed:	57                   	push   %edi
  1012ee:	56                   	push   %esi
  1012ef:	53                   	push   %ebx
  1012f0:	81 ec 1c 02 00 00    	sub    $0x21c,%esp
  1012f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1012f9:	8b 55 14             	mov    0x14(%ebp),%edx
  assert(inode);
  1012fc:	85 c0                	test   %eax,%eax
  1012fe:	74 38                	je     101338 <iread+0x4e>
  char *cbuf = buf;
  char dbuf[SECTSIZE];
  uint32_t curr = -1;
  uint32_t total_len = inode->dinode.length;
  101300:	8b 48 10             	mov    0x10(%eax),%ecx
  uint32_t st_sect = inode->dinode.start_sect;
  101303:	8b 40 0c             	mov    0xc(%eax),%eax
  101306:	89 85 d8 fd ff ff    	mov    %eax,-0x228(%ebp)
  int i;
  for (i = 0; i < len && off < total_len; ++i, ++off) {
  10130c:	85 d2                	test   %edx,%edx
  10130e:	0f 84 af 00 00 00    	je     1013c3 <iread+0xd9>
  101314:	3b 4d 0c             	cmp    0xc(%ebp),%ecx
  101317:	0f 86 b2 00 00 00    	jbe    1013cf <iread+0xe5>
  10131d:	2b 4d 0c             	sub    0xc(%ebp),%ecx
  101320:	89 8d dc fd ff ff    	mov    %ecx,-0x224(%ebp)
  101326:	89 95 e0 fd ff ff    	mov    %edx,-0x220(%ebp)
  10132c:	bb 00 00 00 00       	mov    $0x0,%ebx
  uint32_t curr = -1;
  101331:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  101336:	eb 3e                	jmp    101376 <iread+0x8c>
  assert(inode);
  101338:	83 ec 04             	sub    $0x4,%esp
  10133b:	68 3e 40 10 00       	push   $0x10403e
  101340:	6a 32                	push   $0x32
  101342:	68 44 40 10 00       	push   $0x104044
  101347:	e8 b4 fc ff ff       	call   101000 <abort>
    if (curr != off / SECTSIZE) {
      read_disk(dbuf, st_sect + off / SECTSIZE);
      curr = off / SECTSIZE;
    }
    *cbuf++ = dbuf[off % SECTSIZE];
  10134c:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
  101352:	8a 84 35 e8 fd ff ff 	mov    -0x218(%ebp,%esi,1),%al
  101359:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10135c:	8b 95 e4 fd ff ff    	mov    -0x21c(%ebp),%edx
  101362:	88 04 11             	mov    %al,(%ecx,%edx,1)
  for (i = 0; i < len && off < total_len; ++i, ++off) {
  101365:	43                   	inc    %ebx
  101366:	3b 9d e0 fd ff ff    	cmp    -0x220(%ebp),%ebx
  10136c:	74 47                	je     1013b5 <iread+0xcb>
  10136e:	39 9d dc fd ff ff    	cmp    %ebx,-0x224(%ebp)
  101374:	74 33                	je     1013a9 <iread+0xbf>
  101376:	89 9d e4 fd ff ff    	mov    %ebx,-0x21c(%ebp)
  10137c:	89 de                	mov    %ebx,%esi
  10137e:	03 75 0c             	add    0xc(%ebp),%esi
    if (curr != off / SECTSIZE) {
  101381:	89 f8                	mov    %edi,%eax
  101383:	89 f7                	mov    %esi,%edi
  101385:	c1 ef 09             	shr    $0x9,%edi
  101388:	39 c7                	cmp    %eax,%edi
  10138a:	74 c0                	je     10134c <iread+0x62>
      read_disk(dbuf, st_sect + off / SECTSIZE);
  10138c:	83 ec 08             	sub    $0x8,%esp
  10138f:	8b 85 d8 fd ff ff    	mov    -0x228(%ebp),%eax
  101395:	01 f8                	add    %edi,%eax
  101397:	50                   	push   %eax
  101398:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
  10139e:	50                   	push   %eax
  10139f:	e8 c3 0f 00 00       	call   102367 <read_disk>
  1013a4:	83 c4 10             	add    $0x10,%esp
  1013a7:	eb a3                	jmp    10134c <iread+0x62>
  for (i = 0; i < len && off < total_len; ++i, ++off) {
  1013a9:	8b 85 dc fd ff ff    	mov    -0x224(%ebp),%eax
  1013af:	89 85 e0 fd ff ff    	mov    %eax,-0x220(%ebp)
  }
  return i;
}
  1013b5:	8b 85 e0 fd ff ff    	mov    -0x220(%ebp),%eax
  1013bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1013be:	5b                   	pop    %ebx
  1013bf:	5e                   	pop    %esi
  1013c0:	5f                   	pop    %edi
  1013c1:	5d                   	pop    %ebp
  1013c2:	c3                   	ret    
  for (i = 0; i < len && off < total_len; ++i, ++off) {
  1013c3:	c7 85 e0 fd ff ff 00 	movl   $0x0,-0x220(%ebp)
  1013ca:	00 00 00 
  1013cd:	eb e6                	jmp    1013b5 <iread+0xcb>
  1013cf:	c7 85 e0 fd ff ff 00 	movl   $0x0,-0x220(%ebp)
  1013d6:	00 00 00 
  return i;
  1013d9:	eb da                	jmp    1013b5 <iread+0xcb>

001013db <iadddev>:

void iadddev(const char *name, int id) {
  1013db:	55                   	push   %ebp
  1013dc:	89 e5                	mov    %esp,%ebp
  1013de:	53                   	push   %ebx
  1013df:	83 ec 04             	sub    $0x4,%esp
  1013e2:	8b 45 0c             	mov    0xc(%ebp),%eax
  assert(id < MAX_DEV);
  1013e5:	83 f8 0f             	cmp    $0xf,%eax
  1013e8:	7f 46                	jg     101430 <iadddev+0x55>
  inode_t *inode = &inodes[MAX_FILE + id];
  inode->valid = 1;
  1013ea:	8d 54 80 50          	lea    0x50(%eax,%eax,4),%edx
  1013ee:	01 d2                	add    %edx,%edx
  1013f0:	8d 4c 10 10          	lea    0x10(%eax,%edx,1),%ecx
  1013f4:	c1 e1 02             	shl    $0x2,%ecx
  1013f7:	c7 81 20 6c 10 00 01 	movl   $0x1,0x106c20(%ecx)
  1013fe:	00 00 00 
  inode->type = TYPE_DEV;
  101401:	c7 81 24 6c 10 00 03 	movl   $0x3,0x106c24(%ecx)
  101408:	00 00 00 
  inode->dev = id;
  10140b:	89 81 28 6c 10 00    	mov    %eax,0x106c28(%ecx)
  strcpy(inode->dinode.name, name);
  101411:	83 ec 08             	sub    $0x8,%esp
  101414:	ff 75 08             	push   0x8(%ebp)
  101417:	8d 44 10 10          	lea    0x10(%eax,%edx,1),%eax
  10141b:	8d 04 85 34 6c 10 00 	lea    0x106c34(,%eax,4),%eax
  101422:	50                   	push   %eax
  101423:	e8 f8 23 00 00       	call   103820 <strcpy>
}
  101428:	83 c4 10             	add    $0x10,%esp
  10142b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10142e:	c9                   	leave  
  10142f:	c3                   	ret    
  assert(id < MAX_DEV);
  101430:	83 ec 04             	sub    $0x4,%esp
  101433:	68 54 40 10 00       	push   $0x104054
  101438:	6a 44                	push   $0x44
  10143a:	68 44 40 10 00       	push   $0x104044
  10143f:	e8 bc fb ff ff       	call   101000 <abort>

00101444 <isize>:

uint32_t isize(inode_t *inode) {
  101444:	55                   	push   %ebp
  101445:	89 e5                	mov    %esp,%ebp
  return inode->dinode.length;
  101447:	8b 45 08             	mov    0x8(%ebp),%eax
  10144a:	8b 40 10             	mov    0x10(%eax),%eax
}
  10144d:	5d                   	pop    %ebp
  10144e:	c3                   	ret    

0010144f <itype>:

int itype(inode_t *inode) {
  10144f:	55                   	push   %ebp
  101450:	89 e5                	mov    %esp,%ebp
  return inode->type;
  101452:	8b 45 08             	mov    0x8(%ebp),%eax
  101455:	8b 40 04             	mov    0x4(%eax),%eax
}
  101458:	5d                   	pop    %ebp
  101459:	c3                   	ret    

0010145a <ino>:

uint32_t ino(inode_t *inode) {
  10145a:	55                   	push   %ebp
  10145b:	89 e5                	mov    %esp,%ebp
  return inode - inodes;
  10145d:	8b 45 08             	mov    0x8(%ebp),%eax
  101460:	2d 20 6c 10 00       	sub    $0x106c20,%eax
  101465:	c1 f8 02             	sar    $0x2,%eax
  101468:	8d 0c c0             	lea    (%eax,%eax,8),%ecx
  10146b:	89 ca                	mov    %ecx,%edx
  10146d:	c1 e2 05             	shl    $0x5,%edx
  101470:	29 ca                	sub    %ecx,%edx
  101472:	8d 14 90             	lea    (%eax,%edx,4),%edx
  101475:	8d 0c d0             	lea    (%eax,%edx,8),%ecx
  101478:	89 ca                	mov    %ecx,%edx
  10147a:	c1 e2 0f             	shl    $0xf,%edx
  10147d:	29 ca                	sub    %ecx,%edx
  10147f:	8d 04 90             	lea    (%eax,%edx,4),%eax
  101482:	f7 d8                	neg    %eax
}
  101484:	5d                   	pop    %ebp
  101485:	c3                   	ret    

00101486 <idevid>:

int idevid(inode_t *inode) {
  101486:	55                   	push   %ebp
  101487:	89 e5                	mov    %esp,%ebp
  101489:	8b 45 08             	mov    0x8(%ebp),%eax
  return inode->type == TYPE_DEV ? inode->dev : -1;
  10148c:	83 78 04 03          	cmpl   $0x3,0x4(%eax)
  101490:	75 05                	jne    101497 <idevid+0x11>
  101492:	8b 40 08             	mov    0x8(%eax),%eax
}
  101495:	5d                   	pop    %ebp
  101496:	c3                   	ret    
  return inode->type == TYPE_DEV ? inode->dev : -1;
  101497:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  10149c:	eb f7                	jmp    101495 <idevid+0xf>

0010149e <iwrite>:

int iwrite(inode_t *inode, uint32_t off, const void *buf, uint32_t len) {
  10149e:	55                   	push   %ebp
  10149f:	89 e5                	mov    %esp,%ebp
  1014a1:	83 ec 0c             	sub    $0xc,%esp
  panic("write doesn't support");
  1014a4:	68 61 40 10 00       	push   $0x104061
  1014a9:	6a 5d                	push   $0x5d
  1014ab:	68 44 40 10 00       	push   $0x104044
  1014b0:	e8 4b fb ff ff       	call   101000 <abort>

001014b5 <itrunc>:
}

void itrunc(inode_t *inode) {
  1014b5:	55                   	push   %ebp
  1014b6:	89 e5                	mov    %esp,%ebp
  1014b8:	83 ec 0c             	sub    $0xc,%esp
  panic("trunc doesn't support");
  1014bb:	68 77 40 10 00       	push   $0x104077
  1014c0:	6a 61                	push   $0x61
  1014c2:	68 44 40 10 00       	push   $0x104044
  1014c7:	e8 34 fb ff ff       	call   101000 <abort>

001014cc <idup>:
}

inode_t *idup(inode_t *inode) {
  1014cc:	55                   	push   %ebp
  1014cd:	89 e5                	mov    %esp,%ebp
  return inode;
}
  1014cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1014d2:	5d                   	pop    %ebp
  1014d3:	c3                   	ret    

001014d4 <iclose>:

void iclose(inode_t *inode) { /* do nothing */ }
  1014d4:	c3                   	ret    

001014d5 <iremove>:

int iremove(const char *path) {
  1014d5:	55                   	push   %ebp
  1014d6:	89 e5                	mov    %esp,%ebp
  1014d8:	83 ec 0c             	sub    $0xc,%esp
  panic("remove doesn't support");
  1014db:	68 8d 40 10 00       	push   $0x10408d
  1014e0:	6a 6b                	push   $0x6b
  1014e2:	68 44 40 10 00       	push   $0x104044
  1014e7:	e8 14 fb ff ff       	call   101000 <abort>

001014ec <init_gdt>:
page_t *free_page_list;

void init_gdt()
{
  static SegDesc gdt[NR_SEG];
  gdt[SEG_KCODE] = SEG32(STA_X | STA_R, 0, 0xffffffff, DPL_KERN);
  1014ec:	66 c7 05 28 80 10 00 	movw   $0xffff,0x108028
  1014f3:	ff ff 
  1014f5:	66 c7 05 2a 80 10 00 	movw   $0x0,0x10802a
  1014fc:	00 00 
  1014fe:	c6 05 2c 80 10 00 00 	movb   $0x0,0x10802c
  101505:	c6 05 2d 80 10 00 9a 	movb   $0x9a,0x10802d
  10150c:	c6 05 2e 80 10 00 cf 	movb   $0xcf,0x10802e
  101513:	c6 05 2f 80 10 00 00 	movb   $0x0,0x10802f
  gdt[SEG_KDATA] = SEG32(STA_W, 0, 0xffffffff, DPL_KERN);
  10151a:	66 c7 05 30 80 10 00 	movw   $0xffff,0x108030
  101521:	ff ff 
  101523:	66 c7 05 32 80 10 00 	movw   $0x0,0x108032
  10152a:	00 00 
  10152c:	c6 05 34 80 10 00 00 	movb   $0x0,0x108034
  101533:	c6 05 35 80 10 00 92 	movb   $0x92,0x108035
  10153a:	c6 05 36 80 10 00 cf 	movb   $0xcf,0x108036
  101541:	c6 05 37 80 10 00 00 	movb   $0x0,0x108037
  gdt[SEG_UCODE] = SEG32(STA_X | STA_R, 0, 0xffffffff, DPL_USER);
  101548:	66 c7 05 38 80 10 00 	movw   $0xffff,0x108038
  10154f:	ff ff 
  101551:	66 c7 05 3a 80 10 00 	movw   $0x0,0x10803a
  101558:	00 00 
  10155a:	c6 05 3c 80 10 00 00 	movb   $0x0,0x10803c
  101561:	c6 05 3d 80 10 00 fa 	movb   $0xfa,0x10803d
  101568:	c6 05 3e 80 10 00 cf 	movb   $0xcf,0x10803e
  10156f:	c6 05 3f 80 10 00 00 	movb   $0x0,0x10803f
  gdt[SEG_UDATA] = SEG32(STA_W, 0, 0xffffffff, DPL_USER);
  101576:	66 c7 05 40 80 10 00 	movw   $0xffff,0x108040
  10157d:	ff ff 
  10157f:	66 c7 05 42 80 10 00 	movw   $0x0,0x108042
  101586:	00 00 
  101588:	c6 05 44 80 10 00 00 	movb   $0x0,0x108044
  10158f:	c6 05 45 80 10 00 f2 	movb   $0xf2,0x108045
  101596:	c6 05 46 80 10 00 cf 	movb   $0xcf,0x108046
  10159d:	c6 05 47 80 10 00 00 	movb   $0x0,0x108047
  gdt[SEG_TSS] = SEG16(STS_T32A, &tss, sizeof(tss) - 1, DPL_KERN);
  1015a4:	66 c7 05 48 80 10 00 	movw   $0x67,0x108048
  1015ab:	67 00 
  1015ad:	b8 00 a0 12 00       	mov    $0x12a000,%eax
  1015b2:	66 a3 4a 80 10 00    	mov    %ax,0x10804a
  1015b8:	89 c2                	mov    %eax,%edx
  1015ba:	c1 ea 10             	shr    $0x10,%edx
  1015bd:	88 15 4c 80 10 00    	mov    %dl,0x10804c
  1015c3:	c6 05 4d 80 10 00 89 	movb   $0x89,0x10804d
  1015ca:	c6 05 4e 80 10 00 40 	movb   $0x40,0x10804e
  1015d1:	c1 e8 18             	shr    $0x18,%eax
  1015d4:	a2 4f 80 10 00       	mov    %al,0x10804f
static inline void set_gdt(void *gdt, int size) {
  static volatile struct {
    int16_t size;
    void *gdt;
  } __attribute__((packed)) data;
  data.size = size;
  1015d9:	66 c7 05 04 80 10 00 	movw   $0x30,0x108004
  1015e0:	30 00 
  data.gdt = gdt;
  1015e2:	c7 05 06 80 10 00 20 	movl   $0x108020,0x108006
  1015e9:	80 10 00 
  asm volatile ("lgdt (%0)" : : "r"(&data));
  1015ec:	b8 04 80 10 00       	mov    $0x108004,%eax
  1015f1:	0f 01 10             	lgdtl  (%eax)
}

static inline void set_tr(int selector) {
  asm volatile ("ltr %0" : : "r"((uint16_t)selector));
  1015f4:	b8 28 00 00 00       	mov    $0x28,%eax
  1015f9:	0f 00 d8             	ltr    %ax
  set_gdt(gdt, sizeof(gdt[0]) * NR_SEG);
  set_tr(KSEL(SEG_TSS));
}
  1015fc:	c3                   	ret    

001015fd <set_tss>:

void set_tss(uint32_t ss0, uint32_t esp0)
{
  1015fd:	55                   	push   %ebp
  1015fe:	89 e5                	mov    %esp,%ebp
  tss.ss0 = ss0;
  101600:	8b 45 08             	mov    0x8(%ebp),%eax
  101603:	a3 08 a0 12 00       	mov    %eax,0x12a008
  tss.esp0 = esp0;
  101608:	8b 45 0c             	mov    0xc(%ebp),%eax
  10160b:	a3 04 a0 12 00       	mov    %eax,0x12a004
}
  101610:	5d                   	pop    %ebp
  101611:	c3                   	ret    

00101612 <init_page>:

static PD kpd;
static PT kpt[PHY_MEM / PT_SIZE] __attribute__((used));

void init_page()
{
  101612:	55                   	push   %ebp
  101613:	89 e5                	mov    %esp,%ebp
  101615:	57                   	push   %edi
  101616:	56                   	push   %esi
  101617:	53                   	push   %ebx
  101618:	83 ec 1c             	sub    $0x1c,%esp
  extern char end; // end的地址：kernel的静态内存的顶端
  panic_on((size_t)(&end) >= KER_MEM - PGSIZE, "Kernel too big (MLE)");
  10161b:	b8 44 c8 13 00       	mov    $0x13c844,%eax
  101620:	3d ff ef 1f 00       	cmp    $0x1fefff,%eax
  101625:	0f 87 9e 00 00 00    	ja     1016c9 <init_page+0xb7>
  10162b:	bf 00 90 10 00       	mov    $0x109000,%edi
  101630:	bb 00 00 00 00       	mov    $0x0,%ebx
  static_assert(sizeof(PTE) == 4, "PTE must be 4 bytes");
  static_assert(sizeof(PDE) == 4, "PDE must be 4 bytes");
  static_assert(sizeof(PT) == PGSIZE, "PT must be one page");
  static_assert(sizeof(PD) == PGSIZE, "PD must be one page");
  // Lab1-4: init kpd and kpt, identity mapping of [0 (or 4096), PHY_MEM)
  for (int i = 0; i < PHY_MEM / PT_SIZE; i++) // PT_SIZE:0X00400000
  101635:	be 00 00 00 00       	mov    $0x0,%esi
  {
    kpd.pde[i].val = MAKE_PDE(&kpt[i], 3); // 把kpd的第i个PDE对应到kpt[i]这个页表
  10163a:	89 f8                	mov    %edi,%eax
  10163c:	83 c8 03             	or     $0x3,%eax
  10163f:	89 04 b5 00 90 12 00 	mov    %eax,0x129000(,%esi,4)
  101646:	89 f9                	mov    %edi,%ecx
  101648:	b8 00 00 00 00       	mov    $0x0,%eax
    for (int j = 0; j < NR_PTE; j++)
    {
      kpt[i].pte[j].val = MAKE_PTE(((i << DIR_SHIFT) | (j << TBL_SHIFT)), 3);
  10164d:	89 c2                	mov    %eax,%edx
  10164f:	09 da                	or     %ebx,%edx
  101651:	83 ca 03             	or     $0x3,%edx
  101654:	89 11                	mov    %edx,(%ecx)
    for (int j = 0; j < NR_PTE; j++)
  101656:	05 00 10 00 00       	add    $0x1000,%eax
  10165b:	83 c1 04             	add    $0x4,%ecx
  10165e:	3d 00 00 40 00       	cmp    $0x400000,%eax
  101663:	75 e8                	jne    10164d <init_page+0x3b>
  for (int i = 0; i < PHY_MEM / PT_SIZE; i++) // PT_SIZE:0X00400000
  101665:	46                   	inc    %esi
  101666:	81 c7 00 10 00 00    	add    $0x1000,%edi
  10166c:	81 c3 00 00 40 00    	add    $0x400000,%ebx
  101672:	83 fe 20             	cmp    $0x20,%esi
  101675:	75 c3                	jne    10163a <init_page+0x28>
    }
  }
  kpt[0].pte[0].val = 0;
  101677:	c7 05 00 90 10 00 00 	movl   $0x0,0x109000
  10167e:	00 00 00 
  asm volatile ("mov %%cr3, %0" : "=r"(val));
  return val;
}

static inline void set_cr3(void *pdir) {
  asm volatile ("mov %0, %%cr3" : : "r"(pdir));
  101681:	b8 00 90 12 00       	mov    $0x129000,%eax
  101686:	0f 22 d8             	mov    %eax,%cr3
  asm volatile ("mov %%cr0, %0" : "=r"(val));
  101689:	0f 20 c0             	mov    %cr0,%eax
  10168c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return val;
  10168f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  set_cr3(&kpd);
  set_cr0(get_cr0() | CR0_PG);
  101692:	0d 00 00 00 80       	or     $0x80000000,%eax
  asm volatile ("mov %0, %%cr0" : : "r"(cr0));
  101697:	0f 22 c0             	mov    %eax,%cr0
  // Lab1-4: init free memory at [KER_MEM, PHY_MEM), a heap for kernel
  // 采用空闲页单链表的写法
  free_page_list = (page_t *)KER_MEM;
  10169a:	c7 05 00 80 10 00 00 	movl   $0x200000,0x108000
  1016a1:	00 20 00 
  for (int addr = KER_MEM + PGSIZE; addr < PHY_MEM; addr += PGSIZE)
  1016a4:	b8 00 10 20 00       	mov    $0x201000,%eax
  {
    page_t *new_page = (page_t *)addr;
    page_t *next = free_page_list->next;
  1016a9:	8b 15 00 80 10 00    	mov    0x108000,%edx
  1016af:	8b 0a                	mov    (%edx),%ecx
    free_page_list->next = new_page;
  1016b1:	89 02                	mov    %eax,(%edx)
    new_page->next = next;
  1016b3:	89 08                	mov    %ecx,(%eax)
  for (int addr = KER_MEM + PGSIZE; addr < PHY_MEM; addr += PGSIZE)
  1016b5:	05 00 10 00 00       	add    $0x1000,%eax
  1016ba:	3d 00 00 00 08       	cmp    $0x8000000,%eax
  1016bf:	75 e8                	jne    1016a9 <init_page+0x97>
  }
}
  1016c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1016c4:	5b                   	pop    %ebx
  1016c5:	5e                   	pop    %esi
  1016c6:	5f                   	pop    %edi
  1016c7:	5d                   	pop    %ebp
  1016c8:	c3                   	ret    
  panic_on((size_t)(&end) >= KER_MEM - PGSIZE, "Kernel too big (MLE)");
  1016c9:	83 ec 04             	sub    $0x4,%esp
  1016cc:	68 a4 40 10 00       	push   $0x1040a4
  1016d1:	6a 27                	push   $0x27
  1016d3:	68 b9 40 10 00       	push   $0x1040b9
  1016d8:	e8 23 f9 ff ff       	call   101000 <abort>

001016dd <kalloc>:

// 分配一页（4KiB）内存并返回其地址，要求分配出的内存按页对齐
void *kalloc() // 链表头删
{
  // Lab1-4: alloc a page from kernel heap, abort when heap empty
  if (free_page_list->next == NULL) // kalloc没有空闲内存时assert(0)
  1016dd:	8b 15 00 80 10 00    	mov    0x108000,%edx
  1016e3:	8b 02                	mov    (%edx),%eax
  1016e5:	85 c0                	test   %eax,%eax
  1016e7:	74 05                	je     1016ee <kalloc+0x11>
    assert(0);
  else
  {
    page_t *delete_page = free_page_list->next;
    free_page_list->next = delete_page->next;
  1016e9:	8b 08                	mov    (%eax),%ecx
  1016eb:	89 0a                	mov    %ecx,(%edx)
    PT *new_page = (PT *)delete_page; // 要求按页对齐所以用PT对一下?
    return new_page;
  }
}
  1016ed:	c3                   	ret    
{
  1016ee:	55                   	push   %ebp
  1016ef:	89 e5                	mov    %esp,%ebp
  1016f1:	83 ec 0c             	sub    $0xc,%esp
    assert(0);
  1016f4:	68 d9 40 10 00       	push   $0x1040d9
  1016f9:	6a 49                	push   $0x49
  1016fb:	68 b9 40 10 00       	push   $0x1040b9
  101700:	e8 fb f8 ff ff       	call   101000 <abort>

00101705 <kfree>:

// 回收ptr指向的那一页内存，要求ptr指向之前分配出去的某一页
void kfree(void *ptr) // 链表头插
{
  101705:	55                   	push   %ebp
  101706:	89 e5                	mov    %esp,%ebp
  101708:	8b 45 08             	mov    0x8(%ebp),%eax
  // Lab1-4: free a page to kernel heap
  // you can just do nothing :)
  // TODO();
  page_t *new_page = ptr;
  page_t *next = free_page_list->next;
  10170b:	8b 15 00 80 10 00    	mov    0x108000,%edx
  101711:	8b 0a                	mov    (%edx),%ecx
  free_page_list->next = new_page;
  101713:	89 02                	mov    %eax,(%edx)
  new_page->next = next;
  101715:	89 08                	mov    %ecx,(%eax)
}
  101717:	5d                   	pop    %ebp
  101718:	c3                   	ret    

00101719 <vm_alloc>:

PD *vm_alloc()
{
  101719:	55                   	push   %ebp
  10171a:	89 e5                	mov    %esp,%ebp
  10171c:	53                   	push   %ebx
  10171d:	83 ec 04             	sub    $0x4,%esp
  // Lab1-4: alloc a new pgdir, map memory under PHY_MEM identityly
  PD *new_dir = (PD *)PAGE_DOWN(kalloc()); // 是否需要PAGE_DOWN?
  101720:	e8 b8 ff ff ff       	call   1016dd <kalloc>
  101725:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  for (int i = 0; i < NR_PDE; i++)
  10172a:	b9 00 90 10 00       	mov    $0x109000,%ecx
  PD *new_dir = (PD *)PAGE_DOWN(kalloc()); // 是否需要PAGE_DOWN?
  10172f:	ba 01 00 00 00       	mov    $0x1,%edx
  101734:	eb 10                	jmp    101746 <vm_alloc+0x2d>
  {
    if (i < PHY_MEM / PT_SIZE)
      new_dir->pde[i].val = MAKE_PDE(&kpt[i], 1); // 把new_dir的第i个PDE(前32个)对应到kpt[i]这个页表
  101736:	89 cb                	mov    %ecx,%ebx
  101738:	83 cb 01             	or     $0x1,%ebx
  10173b:	89 5c 90 fc          	mov    %ebx,-0x4(%eax,%edx,4)
  for (int i = 0; i < NR_PDE; i++)
  10173f:	42                   	inc    %edx
  101740:	81 c1 00 10 00 00    	add    $0x1000,%ecx
    if (i < PHY_MEM / PT_SIZE)
  101746:	8d 5a ff             	lea    -0x1(%edx),%ebx
  101749:	83 fb 1f             	cmp    $0x1f,%ebx
  10174c:	7e e8                	jle    101736 <vm_alloc+0x1d>
  10174e:	c7 44 90 fc 00 00 00 	movl   $0x0,-0x4(%eax,%edx,4)
  101755:	00 
  for (int i = 0; i < NR_PDE; i++)
  101756:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
  10175c:	7e e1                	jle    10173f <vm_alloc+0x26>
    else
      new_dir->pde[i].val = 0;
  }
  return new_dir;
}
  10175e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101761:	c9                   	leave  
  101762:	c3                   	ret    

00101763 <vm_teardown>:
void vm_teardown(PD *pgdir)
{
  // Lab1-4: free all pages mapping above PHY_MEM in pgdir, then free itself
  // you can just do nothing :)
  // TODO();
}
  101763:	c3                   	ret    

00101764 <vm_curr>:

PD *vm_curr()
{
  101764:	55                   	push   %ebp
  101765:	89 e5                	mov    %esp,%ebp
  101767:	83 ec 10             	sub    $0x10,%esp
  asm volatile ("mov %%cr3, %0" : "=r"(val));
  10176a:	0f 20 d8             	mov    %cr3,%eax
  10176d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return val;
  101770:	8b 45 fc             	mov    -0x4(%ebp),%eax
  return (PD *)PAGE_DOWN(get_cr3());
  101773:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
  101778:	c9                   	leave  
  101779:	c3                   	ret    

0010177a <vm_walkpte>:

PTE *vm_walkpte(PD *pgdir, size_t va, int prot)
{
  10177a:	55                   	push   %ebp
  10177b:	89 e5                	mov    %esp,%ebp
  10177d:	57                   	push   %edi
  10177e:	56                   	push   %esi
  10177f:	53                   	push   %ebx
  101780:	83 ec 0c             	sub    $0xc,%esp
  101783:	8b 75 08             	mov    0x8(%ebp),%esi
  101786:	8b 5d 10             	mov    0x10(%ebp),%ebx
  // Lab1-4: return the pointer of PTE which match va
  // if not exist (PDE of va is empty) and prot&1, alloc PT and fill the PDE
  // if not exist (PDE of va is empty) and !(prot&1), return NULL
  // remember to let pde's prot |= prot, but not pte
  assert((prot & ~7) == 0);
  101789:	f7 c3 f8 ff ff ff    	test   $0xfffffff8,%ebx
  10178f:	75 5a                	jne    1017eb <vm_walkpte+0x71>
  int pd_index = ADDR2DIR(va);                                      // 计算“页目录号”
  101791:	8b 7d 0c             	mov    0xc(%ebp),%edi
  101794:	c1 ef 16             	shr    $0x16,%edi
  PDE *pde = &(pgdir->pde[pd_index]);                               // 找到对应的页目录项
  if ((pde->present | pde->read_write | pde->user_supervisor) == 0) // 有效位为0, 对应pte不存在
  101797:	8a 14 be             	mov    (%esi,%edi,4),%dl
  10179a:	d0 ea                	shr    %dl
  10179c:	0b 14 be             	or     (%esi,%edi,4),%edx
  10179f:	8a 04 be             	mov    (%esi,%edi,4),%al
  1017a2:	c0 e8 02             	shr    $0x2,%al
  1017a5:	09 d0                	or     %edx,%eax
  1017a7:	a8 01                	test   $0x1,%al
  1017a9:	75 54                	jne    1017ff <vm_walkpte+0x85>
  {
    if (prot == 0)
  1017ab:	85 db                	test   %ebx,%ebx
  1017ad:	74 68                	je     101817 <vm_walkpte+0x9d>
      return NULL;
    else // kalloc一页作为页表并清零，用prot作为权限设置这个PDE
    {
      PT *pt = (PT *)PAGE_DOWN(kalloc());
  1017af:	e8 29 ff ff ff       	call   1016dd <kalloc>
  1017b4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1017b9:	89 c1                	mov    %eax,%ecx
      for (int i = 0; i < NR_PTE; i++)
  1017bb:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
        pt->pte[i].val = 0;
  1017c1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      for (int i = 0; i < NR_PTE; i++)
  1017c7:	83 c0 04             	add    $0x4,%eax
  1017ca:	39 d0                	cmp    %edx,%eax
  1017cc:	75 f3                	jne    1017c1 <vm_walkpte+0x47>
      pde->val = MAKE_PDE(pt, prot);
  1017ce:	09 cb                	or     %ecx,%ebx
  1017d0:	83 cb 01             	or     $0x1,%ebx
  1017d3:	89 1c be             	mov    %ebx,(%esi,%edi,4)
      int pt_index = ADDR2TBL(va);     // 计算“页表号”
  1017d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1017d9:	c1 e8 0a             	shr    $0xa,%eax
      PTE *pte = &(pt->pte[pt_index]); // 找到对应的页表项
  1017dc:	25 fc 0f 00 00       	and    $0xffc,%eax
  1017e1:	01 c8                	add    %ecx,%eax
    PT *pt = PDE2PT(*pde);           // 根据PDE找页表的地址
    int pt_index = ADDR2TBL(va);     // 计算“页表号”
    PTE *pte = &(pt->pte[pt_index]); // 找到对应的页表项
    return pte;
  }
}
  1017e3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1017e6:	5b                   	pop    %ebx
  1017e7:	5e                   	pop    %esi
  1017e8:	5f                   	pop    %edi
  1017e9:	5d                   	pop    %ebp
  1017ea:	c3                   	ret    
  assert((prot & ~7) == 0);
  1017eb:	83 ec 04             	sub    $0x4,%esp
  1017ee:	68 ca 40 10 00       	push   $0x1040ca
  1017f3:	6a 7f                	push   $0x7f
  1017f5:	68 b9 40 10 00       	push   $0x1040b9
  1017fa:	e8 01 f8 ff ff       	call   101000 <abort>
    PT *pt = PDE2PT(*pde);           // 根据PDE找页表的地址
  1017ff:	8b 04 be             	mov    (%esi,%edi,4),%eax
  101802:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    int pt_index = ADDR2TBL(va);     // 计算“页表号”
  101807:	8b 55 0c             	mov    0xc(%ebp),%edx
  10180a:	c1 ea 0a             	shr    $0xa,%edx
    PTE *pte = &(pt->pte[pt_index]); // 找到对应的页表项
  10180d:	81 e2 fc 0f 00 00    	and    $0xffc,%edx
  101813:	01 d0                	add    %edx,%eax
    return pte;
  101815:	eb cc                	jmp    1017e3 <vm_walkpte+0x69>
      return NULL;
  101817:	b8 00 00 00 00       	mov    $0x0,%eax
  10181c:	eb c5                	jmp    1017e3 <vm_walkpte+0x69>

0010181e <vm_walk>:

void *vm_walk(PD *pgdir, size_t va, int prot)
{
  10181e:	55                   	push   %ebp
  10181f:	89 e5                	mov    %esp,%ebp
  101821:	83 ec 0c             	sub    $0xc,%esp
  // Lab1-4: translate va to pa
  // if prot&1 and prot voilation ((pte->val & prot & 7) != prot), call vm_pgfault
  // if va is not mapped and !(prot&1), return NULL
  TODO();
  101824:	68 db 40 10 00       	push   $0x1040db
  101829:	68 9f 00 00 00       	push   $0x9f
  10182e:	68 b9 40 10 00       	push   $0x1040b9
  101833:	e8 c8 f7 ff ff       	call   101000 <abort>

00101838 <vm_map>:
}

void vm_map(PD *pgdir, size_t va, size_t len, int prot)
{
  101838:	55                   	push   %ebp
  101839:	89 e5                	mov    %esp,%ebp
  10183b:	57                   	push   %edi
  10183c:	56                   	push   %esi
  10183d:	53                   	push   %ebx
  10183e:	83 ec 1c             	sub    $0x1c,%esp
  101841:	8b 7d 08             	mov    0x8(%ebp),%edi
  101844:	8b 55 0c             	mov    0xc(%ebp),%edx
  101847:	8b 75 14             	mov    0x14(%ebp),%esi
  // Lab1-4: map [PAGE_DOWN(va), PAGE_UP(va+len)) at pgdir, with prot
  // if have already mapped pages, just let pte->prot |= prot
  assert(prot & PTE_P);
  10184a:	f7 c6 01 00 00 00    	test   $0x1,%esi
  101850:	74 61                	je     1018b3 <vm_map+0x7b>
  assert((prot & ~7) == 0);
  101852:	f7 c6 f8 ff ff ff    	test   $0xfffffff8,%esi
  101858:	75 70                	jne    1018ca <vm_map+0x92>
  size_t start = PAGE_DOWN(va);
  10185a:	89 d0                	mov    %edx,%eax
  10185c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  size_t end = PAGE_UP(va + len);
  101861:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101864:	8d 94 0a ff 0f 00 00 	lea    0xfff(%edx,%ecx,1),%edx
  10186b:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  101871:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  assert(start >= PHY_MEM);
  101874:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  101879:	76 66                	jbe    1018e1 <vm_map+0xa9>
  assert(end >= start);
  10187b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  10187e:	77 78                	ja     1018f8 <vm_map+0xc0>
  for (int vaddr = start; vaddr < end; vaddr += PGSIZE)
  101880:	89 c3                	mov    %eax,%ebx
  101882:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  101885:	73 24                	jae    1018ab <vm_map+0x73>
  {
    PTE *pte = vm_walkpte(pgdir, vaddr, prot);
  101887:	83 ec 04             	sub    $0x4,%esp
  10188a:	56                   	push   %esi
  10188b:	53                   	push   %ebx
  10188c:	57                   	push   %edi
  10188d:	e8 e8 fe ff ff       	call   10177a <vm_walkpte>
  101892:	89 c2                	mov    %eax,%edx
    pte->val = MAKE_PTE(vaddr, prot);
  101894:	89 f0                	mov    %esi,%eax
  101896:	09 d8                	or     %ebx,%eax
  101898:	83 c8 01             	or     $0x1,%eax
  10189b:	89 02                	mov    %eax,(%edx)
  for (int vaddr = start; vaddr < end; vaddr += PGSIZE)
  10189d:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  1018a3:	83 c4 10             	add    $0x10,%esp
  1018a6:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
  1018a9:	72 dc                	jb     101887 <vm_map+0x4f>
  }
}
  1018ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1018ae:	5b                   	pop    %ebx
  1018af:	5e                   	pop    %esi
  1018b0:	5f                   	pop    %edi
  1018b1:	5d                   	pop    %ebp
  1018b2:	c3                   	ret    
  assert(prot & PTE_P);
  1018b3:	83 ec 04             	sub    $0x4,%esp
  1018b6:	68 e8 40 10 00       	push   $0x1040e8
  1018bb:	68 a6 00 00 00       	push   $0xa6
  1018c0:	68 b9 40 10 00       	push   $0x1040b9
  1018c5:	e8 36 f7 ff ff       	call   101000 <abort>
  assert((prot & ~7) == 0);
  1018ca:	83 ec 04             	sub    $0x4,%esp
  1018cd:	68 ca 40 10 00       	push   $0x1040ca
  1018d2:	68 a7 00 00 00       	push   $0xa7
  1018d7:	68 b9 40 10 00       	push   $0x1040b9
  1018dc:	e8 1f f7 ff ff       	call   101000 <abort>
  assert(start >= PHY_MEM);
  1018e1:	83 ec 04             	sub    $0x4,%esp
  1018e4:	68 f5 40 10 00       	push   $0x1040f5
  1018e9:	68 aa 00 00 00       	push   $0xaa
  1018ee:	68 b9 40 10 00       	push   $0x1040b9
  1018f3:	e8 08 f7 ff ff       	call   101000 <abort>
  assert(end >= start);
  1018f8:	83 ec 04             	sub    $0x4,%esp
  1018fb:	68 06 41 10 00       	push   $0x104106
  101900:	68 ab 00 00 00       	push   $0xab
  101905:	68 b9 40 10 00       	push   $0x1040b9
  10190a:	e8 f1 f6 ff ff       	call   101000 <abort>

0010190f <vm_unmap>:
  // Lab1-4: unmap and free [va, va+len) at pgdir
  // you can just do nothing :)
  // assert(ADDR2OFF(va) == 0);
  // assert(ADDR2OFF(len) == 0);
  // TODO();
}
  10190f:	c3                   	ret    

00101910 <vm_copycurr>:

void vm_copycurr(PD *pgdir)
{
  101910:	55                   	push   %ebp
  101911:	89 e5                	mov    %esp,%ebp
  101913:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-2: copy memory mapped in curr pd to pgdir
  TODO();
  101916:	68 db 40 10 00       	push   $0x1040db
  10191b:	68 bf 00 00 00       	push   $0xbf
  101920:	68 b9 40 10 00       	push   $0x1040b9
  101925:	e8 d6 f6 ff ff       	call   101000 <abort>

0010192a <vm_pgfault>:
}

void vm_pgfault(size_t va, int errcode)
{
  10192a:	55                   	push   %ebp
  10192b:	89 e5                	mov    %esp,%ebp
  10192d:	83 ec 0c             	sub    $0xc,%esp
  printf("pagefault @ 0x%p, errcode = %d\n", va, errcode);
  101930:	ff 75 0c             	push   0xc(%ebp)
  101933:	ff 75 08             	push   0x8(%ebp)
  101936:	68 1c 41 10 00       	push   $0x10411c
  10193b:	e8 7c f8 ff ff       	call   1011bc <printf>
  panic("pgfault");
  101940:	83 c4 0c             	add    $0xc,%esp
  101943:	68 13 41 10 00       	push   $0x104113
  101948:	68 c5 00 00 00       	push   $0xc5
  10194d:	68 b9 40 10 00       	push   $0x1040b9
  101952:	e8 a9 f6 ff ff       	call   101000 <abort>

00101957 <sys_write>:
    res = ((syshandle_t)(syscall_handle[sysnum]))(arg1, arg2, arg3, arg4, arg5);
  }
  ctx->eax = res;
}

int sys_write(int fd, const void *buf, size_t count) {
  101957:	55                   	push   %ebp
  101958:	89 e5                	mov    %esp,%ebp
  10195a:	83 ec 10             	sub    $0x10,%esp
  // TODO: rewrite me at Lab3-1
  return serial_write(buf, count);
  10195d:	ff 75 10             	push   0x10(%ebp)
  101960:	ff 75 0c             	push   0xc(%ebp)
  101963:	e8 5b 08 00 00       	call   1021c3 <serial_write>
}
  101968:	c9                   	leave  
  101969:	c3                   	ret    

0010196a <sys_read>:

int sys_read(int fd, void *buf, size_t count) {
  10196a:	55                   	push   %ebp
  10196b:	89 e5                	mov    %esp,%ebp
  10196d:	83 ec 10             	sub    $0x10,%esp
  // TODO: rewrite me at Lab3-1
  return serial_read(buf, count);
  101970:	ff 75 10             	push   0x10(%ebp)
  101973:	ff 75 0c             	push   0xc(%ebp)
  101976:	e8 5e 08 00 00       	call   1021d9 <serial_read>
}
  10197b:	c9                   	leave  
  10197c:	c3                   	ret    

0010197d <sys_brk>:

int sys_brk(void *addr) {
  10197d:	55                   	push   %ebp
  10197e:	89 e5                	mov    %esp,%ebp
  101980:	83 ec 08             	sub    $0x8,%esp
  // TODO: Lab1-5
  static size_t brk = 0; // use brk of proc instead of this in Lab2-1
  size_t new_brk = PAGE_UP(addr);
  101983:	8b 45 08             	mov    0x8(%ebp),%eax
  101986:	05 ff 0f 00 00       	add    $0xfff,%eax
  10198b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  if (brk == 0) {
  101990:	8b 15 68 a0 12 00    	mov    0x12a068,%edx
  101996:	85 d2                	test   %edx,%edx
  101998:	75 0c                	jne    1019a6 <sys_brk+0x29>
    brk = new_brk;
  10199a:	a3 68 a0 12 00       	mov    %eax,0x12a068
    TODO();
  } else if (new_brk < brk) {
    // can just do nothing
  }
  return 0;
}
  10199f:	b8 00 00 00 00       	mov    $0x0,%eax
  1019a4:	c9                   	leave  
  1019a5:	c3                   	ret    
  } else if (new_brk > brk) {
  1019a6:	39 c2                	cmp    %eax,%edx
  1019a8:	73 f5                	jae    10199f <sys_brk+0x22>
    TODO();
  1019aa:	83 ec 04             	sub    $0x4,%esp
  1019ad:	68 db 40 10 00       	push   $0x1040db
  1019b2:	6a 31                	push   $0x31
  1019b4:	68 3c 41 10 00       	push   $0x10413c
  1019b9:	e8 42 f6 ff ff       	call   101000 <abort>

001019be <sys_sleep>:

void sys_sleep(int ticks) {
  1019be:	55                   	push   %ebp
  1019bf:	89 e5                	mov    %esp,%ebp
  1019c1:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab1-7
  1019c4:	68 db 40 10 00       	push   $0x1040db
  1019c9:	6a 39                	push   $0x39
  1019cb:	68 3c 41 10 00       	push   $0x10413c
  1019d0:	e8 2b f6 ff ff       	call   101000 <abort>

001019d5 <sys_exec>:
}

int sys_exec(const char *path, char *const argv[]) {
  1019d5:	55                   	push   %ebp
  1019d6:	89 e5                	mov    %esp,%ebp
  1019d8:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab1-8, Lab2-1
  1019db:	68 db 40 10 00       	push   $0x1040db
  1019e0:	6a 3d                	push   $0x3d
  1019e2:	68 3c 41 10 00       	push   $0x10413c
  1019e7:	e8 14 f6 ff ff       	call   101000 <abort>

001019ec <sys_getpid>:
}

int sys_getpid() {
  1019ec:	55                   	push   %ebp
  1019ed:	89 e5                	mov    %esp,%ebp
  1019ef:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab2-1
  1019f2:	68 db 40 10 00       	push   $0x1040db
  1019f7:	6a 41                	push   $0x41
  1019f9:	68 3c 41 10 00       	push   $0x10413c
  1019fe:	e8 fd f5 ff ff       	call   101000 <abort>

00101a03 <sys_fork>:

void sys_yield() {
  proc_yield();
}

int sys_fork() {
  101a03:	55                   	push   %ebp
  101a04:	89 e5                	mov    %esp,%ebp
  101a06:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab2-2
  101a09:	68 db 40 10 00       	push   $0x1040db
  101a0e:	6a 49                	push   $0x49
  101a10:	68 3c 41 10 00       	push   $0x10413c
  101a15:	e8 e6 f5 ff ff       	call   101000 <abort>

00101a1a <sys_exit>:
}

void sys_exit(int status) {
  101a1a:	55                   	push   %ebp
  101a1b:	89 e5                	mov    %esp,%ebp
  101a1d:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab2-3
  101a20:	68 db 40 10 00       	push   $0x1040db
  101a25:	6a 4d                	push   $0x4d
  101a27:	68 3c 41 10 00       	push   $0x10413c
  101a2c:	e8 cf f5 ff ff       	call   101000 <abort>

00101a31 <sys_wait>:
}

int sys_wait(int *status) {
  101a31:	55                   	push   %ebp
  101a32:	89 e5                	mov    %esp,%ebp
  101a34:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab2-3, Lab2-4
  101a37:	68 db 40 10 00       	push   $0x1040db
  101a3c:	6a 51                	push   $0x51
  101a3e:	68 3c 41 10 00       	push   $0x10413c
  101a43:	e8 b8 f5 ff ff       	call   101000 <abort>

00101a48 <sys_sem_open>:
}

int sys_sem_open(int value) {
  101a48:	55                   	push   %ebp
  101a49:	89 e5                	mov    %esp,%ebp
  101a4b:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab2-5
  101a4e:	68 db 40 10 00       	push   $0x1040db
  101a53:	6a 55                	push   $0x55
  101a55:	68 3c 41 10 00       	push   $0x10413c
  101a5a:	e8 a1 f5 ff ff       	call   101000 <abort>

00101a5f <sys_sem_p>:
}

int sys_sem_p(int sem_id) {
  101a5f:	55                   	push   %ebp
  101a60:	89 e5                	mov    %esp,%ebp
  101a62:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab2-5
  101a65:	68 db 40 10 00       	push   $0x1040db
  101a6a:	6a 59                	push   $0x59
  101a6c:	68 3c 41 10 00       	push   $0x10413c
  101a71:	e8 8a f5 ff ff       	call   101000 <abort>

00101a76 <sys_sem_v>:
}

int sys_sem_v(int sem_id) {
  101a76:	55                   	push   %ebp
  101a77:	89 e5                	mov    %esp,%ebp
  101a79:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab2-5
  101a7c:	68 db 40 10 00       	push   $0x1040db
  101a81:	6a 5d                	push   $0x5d
  101a83:	68 3c 41 10 00       	push   $0x10413c
  101a88:	e8 73 f5 ff ff       	call   101000 <abort>

00101a8d <sys_sem_close>:
}

int sys_sem_close(int sem_id) {
  101a8d:	55                   	push   %ebp
  101a8e:	89 e5                	mov    %esp,%ebp
  101a90:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab2-5
  101a93:	68 db 40 10 00       	push   $0x1040db
  101a98:	6a 61                	push   $0x61
  101a9a:	68 3c 41 10 00       	push   $0x10413c
  101a9f:	e8 5c f5 ff ff       	call   101000 <abort>

00101aa4 <sys_open>:
}

int sys_open(const char *path, int mode) {
  101aa4:	55                   	push   %ebp
  101aa5:	89 e5                	mov    %esp,%ebp
  101aa7:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab3-1
  101aaa:	68 db 40 10 00       	push   $0x1040db
  101aaf:	6a 65                	push   $0x65
  101ab1:	68 3c 41 10 00       	push   $0x10413c
  101ab6:	e8 45 f5 ff ff       	call   101000 <abort>

00101abb <sys_close>:
}

int sys_close(int fd) {
  101abb:	55                   	push   %ebp
  101abc:	89 e5                	mov    %esp,%ebp
  101abe:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab3-1
  101ac1:	68 db 40 10 00       	push   $0x1040db
  101ac6:	6a 69                	push   $0x69
  101ac8:	68 3c 41 10 00       	push   $0x10413c
  101acd:	e8 2e f5 ff ff       	call   101000 <abort>

00101ad2 <sys_dup>:
}

int sys_dup(int fd) {
  101ad2:	55                   	push   %ebp
  101ad3:	89 e5                	mov    %esp,%ebp
  101ad5:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab3-1
  101ad8:	68 db 40 10 00       	push   $0x1040db
  101add:	6a 6d                	push   $0x6d
  101adf:	68 3c 41 10 00       	push   $0x10413c
  101ae4:	e8 17 f5 ff ff       	call   101000 <abort>

00101ae9 <sys_lseek>:
}

uint32_t sys_lseek(int fd, uint32_t off, int whence) {
  101ae9:	55                   	push   %ebp
  101aea:	89 e5                	mov    %esp,%ebp
  101aec:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab3-1
  101aef:	68 db 40 10 00       	push   $0x1040db
  101af4:	6a 71                	push   $0x71
  101af6:	68 3c 41 10 00       	push   $0x10413c
  101afb:	e8 00 f5 ff ff       	call   101000 <abort>

00101b00 <sys_fstat>:
}

int sys_fstat(int fd, struct stat *st) {
  101b00:	55                   	push   %ebp
  101b01:	89 e5                	mov    %esp,%ebp
  101b03:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab3-1
  101b06:	68 db 40 10 00       	push   $0x1040db
  101b0b:	6a 75                	push   $0x75
  101b0d:	68 3c 41 10 00       	push   $0x10413c
  101b12:	e8 e9 f4 ff ff       	call   101000 <abort>

00101b17 <sys_chdir>:
}

int sys_chdir(const char *path) {
  101b17:	55                   	push   %ebp
  101b18:	89 e5                	mov    %esp,%ebp
  101b1a:	83 ec 0c             	sub    $0xc,%esp
  TODO(); // Lab3-2
  101b1d:	68 db 40 10 00       	push   $0x1040db
  101b22:	6a 79                	push   $0x79
  101b24:	68 3c 41 10 00       	push   $0x10413c
  101b29:	e8 d2 f4 ff ff       	call   101000 <abort>

00101b2e <sys_mmap>:
  return iremove(path);
}

// optional syscall

void *sys_mmap() {
  101b2e:	55                   	push   %ebp
  101b2f:	89 e5                	mov    %esp,%ebp
  101b31:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101b34:	68 db 40 10 00       	push   $0x1040db
  101b39:	68 83 00 00 00       	push   $0x83
  101b3e:	68 3c 41 10 00       	push   $0x10413c
  101b43:	e8 b8 f4 ff ff       	call   101000 <abort>

00101b48 <sys_munmap>:
}

void sys_munmap(void *addr) {
  101b48:	55                   	push   %ebp
  101b49:	89 e5                	mov    %esp,%ebp
  101b4b:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101b4e:	68 db 40 10 00       	push   $0x1040db
  101b53:	68 87 00 00 00       	push   $0x87
  101b58:	68 3c 41 10 00       	push   $0x10413c
  101b5d:	e8 9e f4 ff ff       	call   101000 <abort>

00101b62 <sys_clone>:
}

int sys_clone(void (*entry)(void*), void *stack, void *arg) {
  101b62:	55                   	push   %ebp
  101b63:	89 e5                	mov    %esp,%ebp
  101b65:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101b68:	68 db 40 10 00       	push   $0x1040db
  101b6d:	68 8b 00 00 00       	push   $0x8b
  101b72:	68 3c 41 10 00       	push   $0x10413c
  101b77:	e8 84 f4 ff ff       	call   101000 <abort>

00101b7c <sys_kill>:
}

int sys_kill(int pid) {
  101b7c:	55                   	push   %ebp
  101b7d:	89 e5                	mov    %esp,%ebp
  101b7f:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101b82:	68 db 40 10 00       	push   $0x1040db
  101b87:	68 8f 00 00 00       	push   $0x8f
  101b8c:	68 3c 41 10 00       	push   $0x10413c
  101b91:	e8 6a f4 ff ff       	call   101000 <abort>

00101b96 <sys_cv_open>:
}

int sys_cv_open() {
  101b96:	55                   	push   %ebp
  101b97:	89 e5                	mov    %esp,%ebp
  101b99:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101b9c:	68 db 40 10 00       	push   $0x1040db
  101ba1:	68 93 00 00 00       	push   $0x93
  101ba6:	68 3c 41 10 00       	push   $0x10413c
  101bab:	e8 50 f4 ff ff       	call   101000 <abort>

00101bb0 <sys_cv_wait>:
}

int sys_cv_wait(int cv_id, int sem_id) {
  101bb0:	55                   	push   %ebp
  101bb1:	89 e5                	mov    %esp,%ebp
  101bb3:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101bb6:	68 db 40 10 00       	push   $0x1040db
  101bbb:	68 97 00 00 00       	push   $0x97
  101bc0:	68 3c 41 10 00       	push   $0x10413c
  101bc5:	e8 36 f4 ff ff       	call   101000 <abort>

00101bca <sys_cv_sig>:
}

int sys_cv_sig(int cv_id) {
  101bca:	55                   	push   %ebp
  101bcb:	89 e5                	mov    %esp,%ebp
  101bcd:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101bd0:	68 db 40 10 00       	push   $0x1040db
  101bd5:	68 9b 00 00 00       	push   $0x9b
  101bda:	68 3c 41 10 00       	push   $0x10413c
  101bdf:	e8 1c f4 ff ff       	call   101000 <abort>

00101be4 <sys_cv_sigall>:
}

int sys_cv_sigall(int cv_id) {
  101be4:	55                   	push   %ebp
  101be5:	89 e5                	mov    %esp,%ebp
  101be7:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101bea:	68 db 40 10 00       	push   $0x1040db
  101bef:	68 9f 00 00 00       	push   $0x9f
  101bf4:	68 3c 41 10 00       	push   $0x10413c
  101bf9:	e8 02 f4 ff ff       	call   101000 <abort>

00101bfe <sys_cv_close>:
}

int sys_cv_close(int cv_id) {
  101bfe:	55                   	push   %ebp
  101bff:	89 e5                	mov    %esp,%ebp
  101c01:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101c04:	68 db 40 10 00       	push   $0x1040db
  101c09:	68 a3 00 00 00       	push   $0xa3
  101c0e:	68 3c 41 10 00       	push   $0x10413c
  101c13:	e8 e8 f3 ff ff       	call   101000 <abort>

00101c18 <sys_pipe>:
}

int sys_pipe(int fd[2]) {
  101c18:	55                   	push   %ebp
  101c19:	89 e5                	mov    %esp,%ebp
  101c1b:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101c1e:	68 db 40 10 00       	push   $0x1040db
  101c23:	68 a7 00 00 00       	push   $0xa7
  101c28:	68 3c 41 10 00       	push   $0x10413c
  101c2d:	e8 ce f3 ff ff       	call   101000 <abort>

00101c32 <sys_link>:
}

int sys_link(const char *oldpath, const char *newpath) {
  101c32:	55                   	push   %ebp
  101c33:	89 e5                	mov    %esp,%ebp
  101c35:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101c38:	68 db 40 10 00       	push   $0x1040db
  101c3d:	68 ab 00 00 00       	push   $0xab
  101c42:	68 3c 41 10 00       	push   $0x10413c
  101c47:	e8 b4 f3 ff ff       	call   101000 <abort>

00101c4c <sys_symlink>:
}

int sys_symlink(const char *oldpath, const char *newpath) {
  101c4c:	55                   	push   %ebp
  101c4d:	89 e5                	mov    %esp,%ebp
  101c4f:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  101c52:	68 db 40 10 00       	push   $0x1040db
  101c57:	68 af 00 00 00       	push   $0xaf
  101c5c:	68 3c 41 10 00       	push   $0x10413c
  101c61:	e8 9a f3 ff ff       	call   101000 <abort>

00101c66 <sys_yield>:
void sys_yield() {
  101c66:	55                   	push   %ebp
  101c67:	89 e5                	mov    %esp,%ebp
  101c69:	83 ec 08             	sub    $0x8,%esp
  proc_yield();
  101c6c:	e8 4f 02 00 00       	call   101ec0 <proc_yield>
}
  101c71:	c9                   	leave  
  101c72:	c3                   	ret    

00101c73 <sys_unlink>:
int sys_unlink(const char *path) {
  101c73:	55                   	push   %ebp
  101c74:	89 e5                	mov    %esp,%ebp
  101c76:	83 ec 14             	sub    $0x14,%esp
  return iremove(path);
  101c79:	ff 75 08             	push   0x8(%ebp)
  101c7c:	e8 54 f8 ff ff       	call   1014d5 <iremove>
}
  101c81:	c9                   	leave  
  101c82:	c3                   	ret    

00101c83 <do_syscall>:
void do_syscall(Context *ctx) {
  101c83:	55                   	push   %ebp
  101c84:	89 e5                	mov    %esp,%ebp
  101c86:	83 ec 14             	sub    $0x14,%esp
    res = ((syshandle_t)(syscall_handle[sysnum]))(arg1, arg2, arg3, arg4, arg5);
  101c89:	6a 00                	push   $0x0
  101c8b:	6a 00                	push   $0x0
  101c8d:	6a 00                	push   $0x0
  101c8f:	6a 00                	push   $0x0
  101c91:	6a 00                	push   $0x0
  101c93:	ff 15 80 55 10 00    	call   *0x105580
  ctx->eax = res;
  101c99:	8b 55 08             	mov    0x8(%ebp),%edx
  101c9c:	89 02                	mov    %eax,(%edx)
}
  101c9e:	83 c4 20             	add    $0x20,%esp
  101ca1:	c9                   	leave  
  101ca2:	c3                   	ret    

00101ca3 <load_elf>:
#include "disk.h"
#include "fs.h"
#include <elf.h>

uint32_t load_elf(PD *pgdir, const char *name)
{
  101ca3:	55                   	push   %ebp
  101ca4:	89 e5                	mov    %esp,%ebp
  101ca6:	57                   	push   %edi
  101ca7:	56                   	push   %esi
  101ca8:	53                   	push   %ebx
  101ca9:	81 ec 84 00 00 00    	sub    $0x84,%esp
  Elf32_Ehdr elf;
  Elf32_Phdr ph;
  inode_t *inode = iopen(name, TYPE_NONE);
  101caf:	6a 00                	push   $0x0
  101cb1:	ff 75 0c             	push   0xc(%ebp)
  101cb4:	e8 dc f5 ff ff       	call   101295 <iopen>
  if (!inode)
  101cb9:	83 c4 10             	add    $0x10,%esp
  101cbc:	85 c0                	test   %eax,%eax
  101cbe:	0f 84 d9 00 00 00    	je     101d9d <load_elf+0xfa>
  101cc4:	89 c6                	mov    %eax,%esi
    return -1;
  iread(inode, 0, &elf, sizeof(elf));
  101cc6:	6a 34                	push   $0x34
  101cc8:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  101ccb:	50                   	push   %eax
  101ccc:	6a 00                	push   $0x0
  101cce:	56                   	push   %esi
  101ccf:	e8 16 f6 ff ff       	call   1012ea <iread>
  if (*(uint32_t *)(&elf) != 0x464c457f)
  101cd4:	83 c4 10             	add    $0x10,%esp
  101cd7:	81 7d b4 7f 45 4c 46 	cmpl   $0x464c457f,-0x4c(%ebp)
  101cde:	75 39                	jne    101d19 <load_elf+0x76>
  { // check ELF magic number
    iclose(inode);
    return -1;
  }
  for (int i = 0; i < elf.e_phnum; ++i)
  101ce0:	bb 00 00 00 00       	mov    $0x0,%ebx
  {
    iread(inode, elf.e_phoff + i * sizeof(ph), &ph, sizeof(ph));
  101ce5:	8d 7d 94             	lea    -0x6c(%ebp),%edi
  for (int i = 0; i < elf.e_phnum; ++i)
  101ce8:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  101ced:	75 46                	jne    101d35 <load_elf+0x92>
      memset((void *)ph.p_vaddr + ph.p_filesz, 0, ph.p_memsz - ph.p_filesz);
      set_cr3(temp_pd);
    }
  }
  // TODO: Lab1-4 alloc stack memory in pgdir
  vm_map(pgdir, USR_MEM - PGSIZE, PGSIZE, 7);
  101cef:	6a 07                	push   $0x7
  101cf1:	68 00 10 00 00       	push   $0x1000
  101cf6:	68 00 f0 ff bf       	push   $0xbffff000
  101cfb:	ff 75 08             	push   0x8(%ebp)
  101cfe:	e8 35 fb ff ff       	call   101838 <vm_map>
  iclose(inode);
  101d03:	89 34 24             	mov    %esi,(%esp)
  101d06:	e8 c9 f7 ff ff       	call   1014d4 <iclose>
  return elf.e_entry;
  101d0b:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101d0e:	83 c4 10             	add    $0x10,%esp
}
  101d11:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101d14:	5b                   	pop    %ebx
  101d15:	5e                   	pop    %esi
  101d16:	5f                   	pop    %edi
  101d17:	5d                   	pop    %ebp
  101d18:	c3                   	ret    
    iclose(inode);
  101d19:	83 ec 0c             	sub    $0xc,%esp
  101d1c:	56                   	push   %esi
  101d1d:	e8 b2 f7 ff ff       	call   1014d4 <iclose>
    return -1;
  101d22:	83 c4 10             	add    $0x10,%esp
  101d25:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  101d2a:	eb e5                	jmp    101d11 <load_elf+0x6e>
  for (int i = 0; i < elf.e_phnum; ++i)
  101d2c:	43                   	inc    %ebx
  101d2d:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  101d31:	39 d8                	cmp    %ebx,%eax
  101d33:	7e ba                	jle    101cef <load_elf+0x4c>
    iread(inode, elf.e_phoff + i * sizeof(ph), &ph, sizeof(ph));
  101d35:	6a 20                	push   $0x20
  101d37:	57                   	push   %edi
  101d38:	89 d8                	mov    %ebx,%eax
  101d3a:	c1 e0 05             	shl    $0x5,%eax
  101d3d:	03 45 d0             	add    -0x30(%ebp),%eax
  101d40:	50                   	push   %eax
  101d41:	56                   	push   %esi
  101d42:	e8 a3 f5 ff ff       	call   1012ea <iread>
    if (ph.p_type == PT_LOAD)
  101d47:	83 c4 10             	add    $0x10,%esp
  101d4a:	83 7d 94 01          	cmpl   $0x1,-0x6c(%ebp)
  101d4e:	75 dc                	jne    101d2c <load_elf+0x89>
      PD *temp_pd = vm_curr();
  101d50:	e8 0f fa ff ff       	call   101764 <vm_curr>
  101d55:	89 45 84             	mov    %eax,-0x7c(%ebp)
  asm volatile ("mov %0, %%cr3" : : "r"(pdir));
  101d58:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101d5b:	0f 22 d9             	mov    %ecx,%cr3
      vm_map(pgdir, ph.p_vaddr, ph.p_memsz, 7);
  101d5e:	6a 07                	push   $0x7
  101d60:	ff 75 a8             	push   -0x58(%ebp)
  101d63:	ff 75 9c             	push   -0x64(%ebp)
  101d66:	51                   	push   %ecx
  101d67:	e8 cc fa ff ff       	call   101838 <vm_map>
      iread(inode, (uint32_t)ph.p_offset, (void *)ph.p_vaddr, (uint32_t)ph.p_filesz);
  101d6c:	ff 75 a4             	push   -0x5c(%ebp)
  101d6f:	ff 75 9c             	push   -0x64(%ebp)
  101d72:	ff 75 98             	push   -0x68(%ebp)
  101d75:	56                   	push   %esi
  101d76:	e8 6f f5 ff ff       	call   1012ea <iread>
      memset((void *)ph.p_vaddr + ph.p_filesz, 0, ph.p_memsz - ph.p_filesz);
  101d7b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  101d7e:	83 c4 1c             	add    $0x1c,%esp
  101d81:	8b 55 a8             	mov    -0x58(%ebp),%edx
  101d84:	29 c2                	sub    %eax,%edx
  101d86:	52                   	push   %edx
  101d87:	6a 00                	push   $0x0
  101d89:	03 45 9c             	add    -0x64(%ebp),%eax
  101d8c:	50                   	push   %eax
  101d8d:	e8 6c 1a 00 00       	call   1037fe <memset>
  101d92:	8b 45 84             	mov    -0x7c(%ebp),%eax
  101d95:	0f 22 d8             	mov    %eax,%cr3
}
  101d98:	83 c4 10             	add    $0x10,%esp
  101d9b:	eb 8f                	jmp    101d2c <load_elf+0x89>
    return -1;
  101d9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  101da2:	e9 6a ff ff ff       	jmp    101d11 <load_elf+0x6e>

00101da7 <load_arg>:

#define MAX_ARGS_NUM 31

uint32_t load_arg(PD *pgdir, char *const argv[])
{
  101da7:	55                   	push   %ebp
  101da8:	89 e5                	mov    %esp,%ebp
  101daa:	83 ec 0c             	sub    $0xc,%esp
  // Lab1-8: Load argv to user stack
  char *stack_top = (char *)vm_walk(pgdir, USR_MEM - PGSIZE, 7) + PGSIZE;
  101dad:	6a 07                	push   $0x7
  101daf:	68 00 f0 ff bf       	push   $0xbffff000
  101db4:	ff 75 08             	push   0x8(%ebp)
  101db7:	e8 62 fa ff ff       	call   10181e <vm_walk>
  size_t argv_va[MAX_ARGS_NUM + 1];
  int argc;
  for (argc = 0; argv[argc]; ++argc)
  101dbc:	83 c4 10             	add    $0x10,%esp
  101dbf:	8b 55 0c             	mov    0xc(%ebp),%edx
  101dc2:	83 3a 00             	cmpl   $0x0,(%edx)
  101dc5:	74 14                	je     101ddb <load_arg+0x34>
  {
    assert(argc < MAX_ARGS_NUM);
    // push the string of argv[argc] to stack, record its va to argv_va[argc]
    TODO();
  101dc7:	83 ec 04             	sub    $0x4,%esp
  101dca:	68 db 40 10 00       	push   $0x1040db
  101dcf:	6a 37                	push   $0x37
  101dd1:	68 51 41 10 00       	push   $0x104151
  101dd6:	e8 25 f2 ff ff       	call   101000 <abort>
  char *stack_top = (char *)vm_walk(pgdir, USR_MEM - PGSIZE, 7) + PGSIZE;
  101ddb:	05 00 10 00 00       	add    $0x1000,%eax
  stack_top -= ADDR2OFF(stack_top) % 4; // align to 4 bytes
  for (int i = argc; i >= 0; --i)
  {
    // push the address of argv_va[argc] to stack to make argv array
    stack_top -= sizeof(size_t);
    *(size_t *)stack_top = argv_va[i];
  101de0:	83 e0 fc             	and    $0xfffffffc,%eax
  101de3:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
  }
  // push the address of the argv array as argument for _start
  TODO();
  101dea:	83 ec 04             	sub    $0x4,%esp
  101ded:	68 db 40 10 00       	push   $0x1040db
  101df2:	6a 42                	push   $0x42
  101df4:	68 51 41 10 00       	push   $0x104151
  101df9:	e8 02 f2 ff ff       	call   101000 <abort>

00101dfe <load_user>:
  stack_top -= sizeof(size_t); // a hole for return value (useless but necessary)
  return USR_MEM - PGSIZE + ADDR2OFF(stack_top);
}

int load_user(PD *pgdir, Context *ctx, const char *name, char *const argv[])
{
  101dfe:	55                   	push   %ebp
  101dff:	89 e5                	mov    %esp,%ebp
  101e01:	53                   	push   %ebx
  101e02:	83 ec 0c             	sub    $0xc,%esp
  101e05:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  size_t eip = load_elf(pgdir, name);
  101e08:	ff 75 10             	push   0x10(%ebp)
  101e0b:	ff 75 08             	push   0x8(%ebp)
  101e0e:	e8 90 fe ff ff       	call   101ca3 <load_elf>
  if (eip == -1)
  101e13:	83 c4 10             	add    $0x10,%esp
  101e16:	83 f8 ff             	cmp    $0xffffffff,%eax
  101e19:	74 22                	je     101e3d <load_user+0x3f>
    return -1;
  ctx->cs = USEL(SEG_UCODE);
  101e1b:	c7 43 20 1b 00 00 00 	movl   $0x1b,0x20(%ebx)
  ctx->ds = USEL(SEG_UDATA);
  101e22:	c7 43 24 23 00 00 00 	movl   $0x23,0x24(%ebx)
  ctx->eip = eip;
  101e29:	89 43 1c             	mov    %eax,0x1c(%ebx)
  // TODO: Lab1-6 init ctx->ss and esp
  ctx->eflags = 0x002; // TODO: Lab1-7 change me to 0x202
  101e2c:	c7 43 28 02 00 00 00 	movl   $0x2,0x28(%ebx)
  return 0;
  101e33:	b8 00 00 00 00       	mov    $0x0,%eax
}
  101e38:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101e3b:	c9                   	leave  
  101e3c:	c3                   	ret    
    return -1;
  101e3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  101e42:	eb f4                	jmp    101e38 <load_user+0x3a>

00101e44 <init_proc>:

void init_proc() {
  // Lab2-1, set status and pgdir
  // Lab2-4, init zombie_sem
  // Lab3-2, set cwd
}
  101e44:	c3                   	ret    

00101e45 <proc_alloc>:

proc_t *proc_alloc() {
  101e45:	55                   	push   %ebp
  101e46:	89 e5                	mov    %esp,%ebp
  101e48:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-1: find a unused pcb from pcb[1..PROC_NUM-1], return NULL if no such one
  TODO();
  101e4b:	68 db 40 10 00       	push   $0x1040db
  101e50:	6a 14                	push   $0x14
  101e52:	68 65 41 10 00       	push   $0x104165
  101e57:	e8 a4 f1 ff ff       	call   101000 <abort>

00101e5c <proc_free>:
  // init ALL attributes of the pcb
}

void proc_free(proc_t *proc) {
  101e5c:	55                   	push   %ebp
  101e5d:	89 e5                	mov    %esp,%ebp
  101e5f:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-1: free proc's pgdir and kstack and mark it UNUSED
  TODO();
  101e62:	68 db 40 10 00       	push   $0x1040db
  101e67:	6a 1a                	push   $0x1a
  101e69:	68 65 41 10 00       	push   $0x104165
  101e6e:	e8 8d f1 ff ff       	call   101000 <abort>

00101e73 <proc_curr>:
}

proc_t *proc_curr() {
  return curr;
}
  101e73:	a1 04 56 10 00       	mov    0x105604,%eax
  101e78:	c3                   	ret    

00101e79 <proc_run>:

void proc_run(proc_t *proc) {
  101e79:	55                   	push   %ebp
  101e7a:	89 e5                	mov    %esp,%ebp
  101e7c:	53                   	push   %ebx
  101e7d:	83 ec 0c             	sub    $0xc,%esp
  101e80:	8b 5d 08             	mov    0x8(%ebp),%ebx
  proc->status = RUNNING;
  101e83:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
  curr = proc;
  101e8a:	89 1d 04 56 10 00    	mov    %ebx,0x105604
  asm volatile ("mov %0, %%cr3" : : "r"(pdir));
  101e90:	8b 43 08             	mov    0x8(%ebx),%eax
  101e93:	0f 22 d8             	mov    %eax,%cr3
  set_cr3(proc->pgdir);
  set_tss(KSEL(SEG_KDATA), (uint32_t)STACK_TOP(proc->kstack));
  101e96:	8b 43 10             	mov    0x10(%ebx),%eax
  101e99:	05 00 10 00 00       	add    $0x1000,%eax
  101e9e:	50                   	push   %eax
  101e9f:	6a 10                	push   $0x10
  101ea1:	e8 57 f7 ff ff       	call   1015fd <set_tss>
  irq_iret(proc->ctx);
  101ea6:	83 c4 04             	add    $0x4,%esp
  101ea9:	ff 73 14             	push   0x14(%ebx)
  101eac:	e8 60 10 00 00       	call   102f11 <irq_iret>

00101eb1 <proc_addready>:
}

void proc_addready(proc_t *proc) {
  101eb1:	55                   	push   %ebp
  101eb2:	89 e5                	mov    %esp,%ebp
  // Lab2-1: mark proc READY
  proc->status = READY;
  101eb4:	8b 45 08             	mov    0x8(%ebp),%eax
  101eb7:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
}
  101ebe:	5d                   	pop    %ebp
  101ebf:	c3                   	ret    

00101ec0 <proc_yield>:

void proc_yield() {
  // Lab2-1: mark curr proc READY, then int $0x81
  curr->status = READY;
  101ec0:	a1 04 56 10 00       	mov    0x105604,%eax
  101ec5:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  INT(0x81);
  101ecc:	cd 81                	int    $0x81
}
  101ece:	c3                   	ret    

00101ecf <proc_copycurr>:

void proc_copycurr(proc_t *proc) {
  101ecf:	55                   	push   %ebp
  101ed0:	89 e5                	mov    %esp,%ebp
  101ed2:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-2: copy curr proc
  // Lab2-5: dup opened usems
  // Lab3-1: dup opened files
  // Lab3-2: dup cwd
  TODO();
  101ed5:	68 db 40 10 00       	push   $0x1040db
  101eda:	6a 39                	push   $0x39
  101edc:	68 65 41 10 00       	push   $0x104165
  101ee1:	e8 1a f1 ff ff       	call   101000 <abort>

00101ee6 <proc_makezombie>:
}

void proc_makezombie(proc_t *proc, int exitcode) {
  101ee6:	55                   	push   %ebp
  101ee7:	89 e5                	mov    %esp,%ebp
  101ee9:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-3: mark proc ZOMBIE and record exitcode, set children's parent to NULL
  // Lab2-5: close opened usem
  // Lab3-1: close opened files
  // Lab3-2: close cwd
  TODO();
  101eec:	68 db 40 10 00       	push   $0x1040db
  101ef1:	6a 41                	push   $0x41
  101ef3:	68 65 41 10 00       	push   $0x104165
  101ef8:	e8 03 f1 ff ff       	call   101000 <abort>

00101efd <proc_findzombie>:
}

proc_t *proc_findzombie(proc_t *proc) {
  101efd:	55                   	push   %ebp
  101efe:	89 e5                	mov    %esp,%ebp
  101f00:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-3: find a ZOMBIE whose parent is proc, return NULL if none
  TODO();
  101f03:	68 db 40 10 00       	push   $0x1040db
  101f08:	6a 46                	push   $0x46
  101f0a:	68 65 41 10 00       	push   $0x104165
  101f0f:	e8 ec f0 ff ff       	call   101000 <abort>

00101f14 <proc_block>:
}

void proc_block() {
  // Lab2-4: mark curr proc BLOCKED, then int $0x81
  curr->status = BLOCKED;
  101f14:	a1 04 56 10 00       	mov    0x105604,%eax
  101f19:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%eax)
  INT(0x81);
  101f20:	cd 81                	int    $0x81
}
  101f22:	c3                   	ret    

00101f23 <proc_allocusem>:

int proc_allocusem(proc_t *proc) {
  101f23:	55                   	push   %ebp
  101f24:	89 e5                	mov    %esp,%ebp
  101f26:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-5: find a free slot in proc->usems, return its index, or -1 if none
  TODO();
  101f29:	68 db 40 10 00       	push   $0x1040db
  101f2e:	6a 51                	push   $0x51
  101f30:	68 65 41 10 00       	push   $0x104165
  101f35:	e8 c6 f0 ff ff       	call   101000 <abort>

00101f3a <proc_getusem>:
}

usem_t *proc_getusem(proc_t *proc, int sem_id) {
  101f3a:	55                   	push   %ebp
  101f3b:	89 e5                	mov    %esp,%ebp
  101f3d:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-5: return proc->usems[sem_id], or NULL if sem_id out of bound
  TODO();
  101f40:	68 db 40 10 00       	push   $0x1040db
  101f45:	6a 56                	push   $0x56
  101f47:	68 65 41 10 00       	push   $0x104165
  101f4c:	e8 af f0 ff ff       	call   101000 <abort>

00101f51 <proc_allocfile>:
}

int proc_allocfile(proc_t *proc) {
  101f51:	55                   	push   %ebp
  101f52:	89 e5                	mov    %esp,%ebp
  101f54:	83 ec 0c             	sub    $0xc,%esp
  // Lab3-1: find a free slot in proc->files, return its index, or -1 if none
  TODO();
  101f57:	68 db 40 10 00       	push   $0x1040db
  101f5c:	6a 5b                	push   $0x5b
  101f5e:	68 65 41 10 00       	push   $0x104165
  101f63:	e8 98 f0 ff ff       	call   101000 <abort>

00101f68 <proc_getfile>:
}

file_t *proc_getfile(proc_t *proc, int fd) {
  101f68:	55                   	push   %ebp
  101f69:	89 e5                	mov    %esp,%ebp
  101f6b:	83 ec 0c             	sub    $0xc,%esp
  // Lab3-1: return proc->files[fd], or NULL if fd out of bound
  TODO();
  101f6e:	68 db 40 10 00       	push   $0x1040db
  101f73:	6a 60                	push   $0x60
  101f75:	68 65 41 10 00       	push   $0x104165
  101f7a:	e8 81 f0 ff ff       	call   101000 <abort>

00101f7f <schedule>:
}

void schedule(Context *ctx) {
  101f7f:	55                   	push   %ebp
  101f80:	89 e5                	mov    %esp,%ebp
  101f82:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-1: save ctx to curr->ctx, then find a READY proc and run it
  TODO();
  101f85:	68 db 40 10 00       	push   $0x1040db
  101f8a:	6a 65                	push   $0x65
  101f8c:	68 65 41 10 00       	push   $0x104165
  101f91:	e8 6a f0 ff ff       	call   101000 <abort>

00101f96 <putchar>:

static inline bool serial_idle() {
  return (inb(SERIAL_PORT + 5) & 0x20) != 0;
}

void putchar(char ch) {
  101f96:	55                   	push   %ebp
  101f97:	89 e5                	mov    %esp,%ebp
  101f99:	8a 4d 08             	mov    0x8(%ebp),%cl
  asm volatile ("inb %1, %0" : "=a"(data) : "d"((uint16_t)port));
  101f9c:	ba fd 03 00 00       	mov    $0x3fd,%edx
  101fa1:	ec                   	in     (%dx),%al
  while (!serial_idle()) ;
  101fa2:	a8 20                	test   $0x20,%al
  101fa4:	74 fb                	je     101fa1 <putchar+0xb>
  asm volatile ("outb %%al, %%dx" : : "a"(data), "d"((uint16_t)port));
  101fa6:	ba f8 03 00 00       	mov    $0x3f8,%edx
  101fab:	88 c8                	mov    %cl,%al
  101fad:	ee                   	out    %al,(%dx)
  outb(SERIAL_PORT, ch);
}
  101fae:	5d                   	pop    %ebp
  101faf:	c3                   	ret    

00101fb0 <init_serial>:
void init_serial() {
  101fb0:	55                   	push   %ebp
  101fb1:	89 e5                	mov    %esp,%ebp
  101fb3:	57                   	push   %edi
  101fb4:	56                   	push   %esi
  101fb5:	53                   	push   %ebx
  101fb6:	83 ec 18             	sub    $0x18,%esp
  101fb9:	bf 00 00 00 00       	mov    $0x0,%edi
  101fbe:	b9 f9 03 00 00       	mov    $0x3f9,%ecx
  101fc3:	89 f8                	mov    %edi,%eax
  101fc5:	89 ca                	mov    %ecx,%edx
  101fc7:	ee                   	out    %al,(%dx)
  101fc8:	be fb 03 00 00       	mov    $0x3fb,%esi
  101fcd:	b0 80                	mov    $0x80,%al
  101fcf:	89 f2                	mov    %esi,%edx
  101fd1:	ee                   	out    %al,(%dx)
  101fd2:	b3 01                	mov    $0x1,%bl
  101fd4:	ba f8 03 00 00       	mov    $0x3f8,%edx
  101fd9:	88 d8                	mov    %bl,%al
  101fdb:	ee                   	out    %al,(%dx)
  101fdc:	89 f8                	mov    %edi,%eax
  101fde:	89 ca                	mov    %ecx,%edx
  101fe0:	ee                   	out    %al,(%dx)
  101fe1:	b0 03                	mov    $0x3,%al
  101fe3:	89 f2                	mov    %esi,%edx
  101fe5:	ee                   	out    %al,(%dx)
  101fe6:	b0 c7                	mov    $0xc7,%al
  101fe8:	ba fa 03 00 00       	mov    $0x3fa,%edx
  101fed:	ee                   	out    %al,(%dx)
  101fee:	b0 0b                	mov    $0xb,%al
  101ff0:	ba fc 03 00 00       	mov    $0x3fc,%edx
  101ff5:	ee                   	out    %al,(%dx)
  101ff6:	88 d8                	mov    %bl,%al
  101ff8:	89 ca                	mov    %ecx,%edx
  101ffa:	ee                   	out    %al,(%dx)
  putchar('\n'); // start a new line
  101ffb:	6a 0a                	push   $0xa
  101ffd:	e8 94 ff ff ff       	call   101f96 <putchar>
}
  102002:	83 c4 10             	add    $0x10,%esp
  102005:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102008:	5b                   	pop    %ebx
  102009:	5e                   	pop    %esi
  10200a:	5f                   	pop    %edi
  10200b:	5d                   	pop    %ebp
  10200c:	c3                   	ret    

0010200d <serial_handle>:
    return buffer[head++ % BUFFER_SIZE];
  }
  return 0;
}

void serial_handle() {
  10200d:	55                   	push   %ebp
  10200e:	89 e5                	mov    %esp,%ebp
  102010:	53                   	push   %ebx
  102011:	83 ec 14             	sub    $0x14,%esp
  asm volatile ("inb %1, %0" : "=a"(data) : "d"((uint16_t)port));
  102014:	bb f8 03 00 00       	mov    $0x3f8,%ebx
  char ch;
  while (inb(SERIAL_PORT + 5) & 0x01) {
  102019:	eb 62                	jmp    10207d <serial_handle+0x70>
    ch = inb(SERIAL_PORT);
    switch (ch) {
  10201b:	8a 45 f7             	mov    -0x9(%ebp),%al
  10201e:	3c 1b                	cmp    $0x1b,%al
  102020:	74 42                	je     102064 <serial_handle+0x57>
  102022:	3c 7f                	cmp    $0x7f,%al
  102024:	74 7f                	je     1020a5 <serial_handle+0x98>
      continue;

    case '\r': ch = '\n'; // Enter
    }
    // printable char
    if (ch == '\n' || (ch >= ' ' && ch < 127)) {
  102026:	8a 45 f7             	mov    -0x9(%ebp),%al
  102029:	83 e8 20             	sub    $0x20,%eax
  10202c:	3c 5e                	cmp    $0x5e,%al
  10202e:	77 4d                	ja     10207d <serial_handle+0x70>
      putchar(ch); // put the char to screen
  102030:	83 ec 0c             	sub    $0xc,%esp
  102033:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
  102037:	50                   	push   %eax
  102038:	e8 59 ff ff ff       	call   101f96 <putchar>
  buffer[tail++ % BUFFER_SIZE] = ch;
  10203d:	a1 84 a6 12 00       	mov    0x12a684,%eax
  102042:	8d 50 01             	lea    0x1(%eax),%edx
  102045:	89 15 84 a6 12 00    	mov    %edx,0x12a684
  10204b:	83 c4 10             	add    $0x10,%esp
  10204e:	25 ff 00 00 80       	and    $0x800000ff,%eax
  102053:	0f 88 dc 00 00 00    	js     102135 <serial_handle+0x128>
  102059:	8a 4d f7             	mov    -0x9(%ebp),%cl
  10205c:	88 88 a0 a6 12 00    	mov    %cl,0x12a6a0(%eax)
  if (ch == '\n') {
  102062:	eb 19                	jmp    10207d <serial_handle+0x70>
  102064:	ba fd 03 00 00       	mov    $0x3fd,%edx
  102069:	ec                   	in     (%dx),%al
      while (inb(SERIAL_PORT + 5) & 0x01) inb(SERIAL_PORT);
  10206a:	a8 01                	test   $0x1,%al
  10206c:	74 0f                	je     10207d <serial_handle+0x70>
  10206e:	b9 fd 03 00 00       	mov    $0x3fd,%ecx
  102073:	89 da                	mov    %ebx,%edx
  102075:	ec                   	in     (%dx),%al
  102076:	89 ca                	mov    %ecx,%edx
  102078:	ec                   	in     (%dx),%al
  102079:	a8 01                	test   $0x1,%al
  10207b:	75 f6                	jne    102073 <serial_handle+0x66>
  10207d:	b9 fd 03 00 00       	mov    $0x3fd,%ecx
  102082:	89 ca                	mov    %ecx,%edx
  102084:	ec                   	in     (%dx),%al
  while (inb(SERIAL_PORT + 5) & 0x01) {
  102085:	a8 01                	test   $0x1,%al
  102087:	0f 84 f2 00 00 00    	je     10217f <serial_handle+0x172>
  10208d:	89 da                	mov    %ebx,%edx
  10208f:	ec                   	in     (%dx),%al
  102090:	88 45 f7             	mov    %al,-0x9(%ebp)
    switch (ch) {
  102093:	3c 0d                	cmp    $0xd,%al
  102095:	74 61                	je     1020f8 <serial_handle+0xeb>
  102097:	77 82                	ja     10201b <serial_handle+0xe>
  102099:	84 c0                	test   %al,%al
  10209b:	74 e5                	je     102082 <serial_handle+0x75>
  10209d:	3c 08                	cmp    $0x8,%al
  10209f:	0f 85 a5 00 00 00    	jne    10214a <serial_handle+0x13d>
  if (tail > clapboard) {
  1020a5:	a1 84 a6 12 00       	mov    0x12a684,%eax
  1020aa:	3b 05 80 a6 12 00    	cmp    0x12a680,%eax
  1020b0:	7e cb                	jle    10207d <serial_handle+0x70>
    return buffer[--tail % BUFFER_SIZE];
  1020b2:	48                   	dec    %eax
  1020b3:	a3 84 a6 12 00       	mov    %eax,0x12a684
  1020b8:	25 ff 00 00 80       	and    $0x800000ff,%eax
  1020bd:	78 30                	js     1020ef <serial_handle+0xe2>
      if (pop_back()) {
  1020bf:	80 b8 a0 a6 12 00 00 	cmpb   $0x0,0x12a6a0(%eax)
  1020c6:	74 b5                	je     10207d <serial_handle+0x70>
        putchar('\b'); putchar(' '); putchar('\b'); // remove it from screen
  1020c8:	83 ec 0c             	sub    $0xc,%esp
  1020cb:	6a 08                	push   $0x8
  1020cd:	e8 c4 fe ff ff       	call   101f96 <putchar>
  1020d2:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1020d9:	e8 b8 fe ff ff       	call   101f96 <putchar>
  1020de:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1020e5:	e8 ac fe ff ff       	call   101f96 <putchar>
  1020ea:	83 c4 10             	add    $0x10,%esp
  1020ed:	eb 8e                	jmp    10207d <serial_handle+0x70>
    return buffer[--tail % BUFFER_SIZE];
  1020ef:	48                   	dec    %eax
  1020f0:	0d 00 ff ff ff       	or     $0xffffff00,%eax
  1020f5:	40                   	inc    %eax
  1020f6:	eb c7                	jmp    1020bf <serial_handle+0xb2>
      putchar(ch); // put the char to screen
  1020f8:	83 ec 0c             	sub    $0xc,%esp
  1020fb:	6a 0a                	push   $0xa
  1020fd:	e8 94 fe ff ff       	call   101f96 <putchar>
  buffer[tail++ % BUFFER_SIZE] = ch;
  102102:	a1 84 a6 12 00       	mov    0x12a684,%eax
  102107:	8d 50 01             	lea    0x1(%eax),%edx
  10210a:	89 15 84 a6 12 00    	mov    %edx,0x12a684
  102110:	83 c4 10             	add    $0x10,%esp
  102113:	25 ff 00 00 80       	and    $0x800000ff,%eax
  102118:	78 12                	js     10212c <serial_handle+0x11f>
  10211a:	c6 80 a0 a6 12 00 0a 	movb   $0xa,0x12a6a0(%eax)
    clapboard = tail;
  102121:	89 15 80 a6 12 00    	mov    %edx,0x12a680
  102127:	e9 51 ff ff ff       	jmp    10207d <serial_handle+0x70>
  buffer[tail++ % BUFFER_SIZE] = ch;
  10212c:	48                   	dec    %eax
  10212d:	0d 00 ff ff ff       	or     $0xffffff00,%eax
  102132:	40                   	inc    %eax
  102133:	eb e5                	jmp    10211a <serial_handle+0x10d>
  102135:	48                   	dec    %eax
  102136:	0d 00 ff ff ff       	or     $0xffffff00,%eax
  10213b:	40                   	inc    %eax
  10213c:	e9 18 ff ff ff       	jmp    102059 <serial_handle+0x4c>
  102141:	48                   	dec    %eax
  102142:	0d 00 ff ff ff       	or     $0xffffff00,%eax
  102147:	40                   	inc    %eax
  102148:	eb 2c                	jmp    102176 <serial_handle+0x169>
    if (ch == '\n' || (ch >= ' ' && ch < 127)) {
  10214a:	80 7d f7 0a          	cmpb   $0xa,-0x9(%ebp)
  10214e:	0f 85 29 ff ff ff    	jne    10207d <serial_handle+0x70>
      putchar(ch); // put the char to screen
  102154:	83 ec 0c             	sub    $0xc,%esp
  102157:	6a 0a                	push   $0xa
  102159:	e8 38 fe ff ff       	call   101f96 <putchar>
  buffer[tail++ % BUFFER_SIZE] = ch;
  10215e:	a1 84 a6 12 00       	mov    0x12a684,%eax
  102163:	8d 50 01             	lea    0x1(%eax),%edx
  102166:	89 15 84 a6 12 00    	mov    %edx,0x12a684
  10216c:	83 c4 10             	add    $0x10,%esp
  10216f:	25 ff 00 00 80       	and    $0x800000ff,%eax
  102174:	78 cb                	js     102141 <serial_handle+0x134>
  102176:	c6 80 a0 a6 12 00 0a 	movb   $0xa,0x12a6a0(%eax)
  if (ch == '\n') {
  10217d:	eb a2                	jmp    102121 <serial_handle+0x114>
      push_back(ch); // put it to the buffer, if it's '\n', move clapboard to tail
    }
  }
}
  10217f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102182:	c9                   	leave  
  102183:	c3                   	ret    

00102184 <getchar>:

char getchar() {
  102184:	55                   	push   %ebp
  102185:	89 e5                	mov    %esp,%ebp
  102187:	83 ec 08             	sub    $0x8,%esp
  char ch;
  while ((ch = pop_front()) == 0) {
  10218a:	eb 0f                	jmp    10219b <getchar+0x17>
    return buffer[head++ % BUFFER_SIZE];
  10218c:	8a 80 a0 a6 12 00    	mov    0x12a6a0(%eax),%al
  while ((ch = pop_front()) == 0) {
  102192:	84 c0                	test   %al,%al
  102194:	75 2b                	jne    1021c1 <getchar+0x3d>
    serial_handle();
  102196:	e8 72 fe ff ff       	call   10200d <serial_handle>
  if (clapboard > head) {
  10219b:	a1 88 a6 12 00       	mov    0x12a688,%eax
  1021a0:	39 05 80 a6 12 00    	cmp    %eax,0x12a680
  1021a6:	7e ee                	jle    102196 <getchar+0x12>
    return buffer[head++ % BUFFER_SIZE];
  1021a8:	8d 50 01             	lea    0x1(%eax),%edx
  1021ab:	89 15 88 a6 12 00    	mov    %edx,0x12a688
  1021b1:	25 ff 00 00 80       	and    $0x800000ff,%eax
  1021b6:	79 d4                	jns    10218c <getchar+0x8>
  1021b8:	48                   	dec    %eax
  1021b9:	0d 00 ff ff ff       	or     $0xffffff00,%eax
  1021be:	40                   	inc    %eax
  1021bf:	eb cb                	jmp    10218c <getchar+0x8>
    //sti(); hlt(); cli(); // change to me in Lab1-7
    //proc_yield(); // change to me in Lab2-1
  }
  // TODO: Lab2-4 rewrite getchar with sem, P(sem) then pop_front
  return ch;
}
  1021c1:	c9                   	leave  
  1021c2:	c3                   	ret    

001021c3 <serial_write>:

int serial_write(const void *buf, size_t count) {
  1021c3:	55                   	push   %ebp
  1021c4:	89 e5                	mov    %esp,%ebp
  1021c6:	83 ec 10             	sub    $0x10,%esp
  putstrn(buf, count);
  1021c9:	ff 75 0c             	push   0xc(%ebp)
  1021cc:	ff 75 08             	push   0x8(%ebp)
  1021cf:	e8 98 ef ff ff       	call   10116c <putstrn>
  return count;
}
  1021d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1021d7:	c9                   	leave  
  1021d8:	c3                   	ret    

001021d9 <serial_read>:

int serial_read(void *buf, size_t count) {
  1021d9:	55                   	push   %ebp
  1021da:	89 e5                	mov    %esp,%ebp
  1021dc:	57                   	push   %edi
  1021dd:	56                   	push   %esi
  1021de:	53                   	push   %ebx
  1021df:	83 ec 0c             	sub    $0xc,%esp
  1021e2:	8b 7d 08             	mov    0x8(%ebp),%edi
  1021e5:	8b 75 0c             	mov    0xc(%ebp),%esi
  char ch = 0;
  int i = 0;
  for (; i < count && ch != '\n'; ++i) {
  1021e8:	85 f6                	test   %esi,%esi
  1021ea:	74 22                	je     10220e <serial_read+0x35>
  int i = 0;
  1021ec:	bb 00 00 00 00       	mov    $0x0,%ebx
    ch = ((char*)buf)[i] = getchar();
  1021f1:	e8 8e ff ff ff       	call   102184 <getchar>
  1021f6:	88 04 1f             	mov    %al,(%edi,%ebx,1)
  for (; i < count && ch != '\n'; ++i) {
  1021f9:	43                   	inc    %ebx
  1021fa:	39 f3                	cmp    %esi,%ebx
  1021fc:	74 06                	je     102204 <serial_read+0x2b>
  1021fe:	3c 0a                	cmp    $0xa,%al
  102200:	75 ef                	jne    1021f1 <serial_read+0x18>
  102202:	89 de                	mov    %ebx,%esi
  }
  return i;
}
  102204:	89 f0                	mov    %esi,%eax
  102206:	83 c4 0c             	add    $0xc,%esp
  102209:	5b                   	pop    %ebx
  10220a:	5e                   	pop    %esi
  10220b:	5f                   	pop    %edi
  10220c:	5d                   	pop    %ebp
  10220d:	c3                   	ret    
  int i = 0;
  10220e:	be 00 00 00 00       	mov    $0x0,%esi
  return i;
  102213:	eb ef                	jmp    102204 <serial_read+0x2b>

00102215 <exception_debug_handler>:
  panic("Oops, you cannot go here!");
}

#else

void exception_debug_handler(Context *ctx) {}
  102215:	c3                   	ret    

00102216 <sem_init>:
#include "klib.h"
#include "sem.h"
#include "proc.h"

void sem_init(sem_t *sem, int value) {
  102216:	55                   	push   %ebp
  102217:	89 e5                	mov    %esp,%ebp
  102219:	83 ec 14             	sub    $0x14,%esp
  10221c:	8b 45 08             	mov    0x8(%ebp),%eax
  sem->value = value;
  10221f:	8b 55 0c             	mov    0xc(%ebp),%edx
  102222:	89 10                	mov    %edx,(%eax)
  list_init(&sem->wait_list);
  102224:	83 c0 04             	add    $0x4,%eax
  102227:	50                   	push   %eax
  102228:	e8 2e ee ff ff       	call   10105b <list_init>
}
  10222d:	83 c4 10             	add    $0x10,%esp
  102230:	c9                   	leave  
  102231:	c3                   	ret    

00102232 <sem_p>:

void sem_p(sem_t *sem) {
  102232:	55                   	push   %ebp
  102233:	89 e5                	mov    %esp,%ebp
  102235:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-4: dec sem's value, if value<0, add curr proc to waitlist and block it
  TODO();
  102238:	68 db 40 10 00       	push   $0x1040db
  10223d:	6a 0c                	push   $0xc
  10223f:	68 77 41 10 00       	push   $0x104177
  102244:	e8 b7 ed ff ff       	call   101000 <abort>

00102249 <sem_v>:
}

void sem_v(sem_t *sem) {
  102249:	55                   	push   %ebp
  10224a:	89 e5                	mov    %esp,%ebp
  10224c:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-4: inc sem's value, if value<=0, dequeue a proc from waitlist and ready it
  TODO();
  10224f:	68 db 40 10 00       	push   $0x1040db
  102254:	6a 11                	push   $0x11
  102256:	68 77 41 10 00       	push   $0x104177
  10225b:	e8 a0 ed ff ff       	call   101000 <abort>

00102260 <usem_alloc>:
}

#define USER_SEM_NUM 128
static usem_t user_sem[USER_SEM_NUM] __attribute__((used));

usem_t *usem_alloc(int value) {
  102260:	55                   	push   %ebp
  102261:	89 e5                	mov    %esp,%ebp
  102263:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-5: find a usem whose ref==0, init it, inc ref and return it, return NULL if none
  TODO();
  102266:	68 db 40 10 00       	push   $0x1040db
  10226b:	6a 19                	push   $0x19
  10226d:	68 77 41 10 00       	push   $0x104177
  102272:	e8 89 ed ff ff       	call   101000 <abort>

00102277 <usem_dup>:
}

usem_t *usem_dup(usem_t *usem) {
  102277:	55                   	push   %ebp
  102278:	89 e5                	mov    %esp,%ebp
  10227a:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-5: inc usem's ref
  TODO();
  10227d:	68 db 40 10 00       	push   $0x1040db
  102282:	6a 1e                	push   $0x1e
  102284:	68 77 41 10 00       	push   $0x104177
  102289:	e8 72 ed ff ff       	call   101000 <abort>

0010228e <usem_close>:
}

void usem_close(usem_t *usem) {
  10228e:	55                   	push   %ebp
  10228f:	89 e5                	mov    %esp,%ebp
  102291:	83 ec 0c             	sub    $0xc,%esp
  // Lab2-5: dec usem's ref
  TODO();
  102294:	68 db 40 10 00       	push   $0x1040db
  102299:	6a 23                	push   $0x23
  10229b:	68 77 41 10 00       	push   $0x104177
  1022a0:	e8 5b ed ff ff       	call   101000 <abort>

001022a5 <fopen>:
static file_t *falloc() {
  // Lab3-1: find a file whose ref==0, init it, inc ref and return it, return NULL if none
  TODO();
}

file_t *fopen(const char *path, int mode) {
  1022a5:	55                   	push   %ebp
  1022a6:	89 e5                	mov    %esp,%ebp
  1022a8:	83 ec 0c             	sub    $0xc,%esp
  TODO();
  1022ab:	68 db 40 10 00       	push   $0x1040db
  1022b0:	6a 0a                	push   $0xa
  1022b2:	68 88 41 10 00       	push   $0x104188
  1022b7:	e8 44 ed ff ff       	call   101000 <abort>

001022bc <fread>:
  if (fp) fclose(fp);
  if (ip) iclose(ip);
  return NULL;
}

int fread(file_t *file, void *buf, uint32_t size) {
  1022bc:	55                   	push   %ebp
  1022bd:	89 e5                	mov    %esp,%ebp
  1022bf:	83 ec 08             	sub    $0x8,%esp
  // Lab3-1, distribute read operation by file's type
  // remember to add offset if type is FILE (check if iread return value >= 0!)
  if (!file->readable) return -1;
  1022c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1022c5:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  1022c9:	75 07                	jne    1022d2 <fread+0x16>
  TODO();
}
  1022cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1022d0:	c9                   	leave  
  1022d1:	c3                   	ret    
  TODO();
  1022d2:	83 ec 04             	sub    $0x4,%esp
  1022d5:	68 db 40 10 00       	push   $0x1040db
  1022da:	6a 37                	push   $0x37
  1022dc:	68 88 41 10 00       	push   $0x104188
  1022e1:	e8 1a ed ff ff       	call   101000 <abort>

001022e6 <fwrite>:

int fwrite(file_t *file, const void *buf, uint32_t size) {
  1022e6:	55                   	push   %ebp
  1022e7:	89 e5                	mov    %esp,%ebp
  1022e9:	83 ec 08             	sub    $0x8,%esp
  // Lab3-1, distribute write operation by file's type
  // remember to add offset if type is FILE (check if iwrite return value >= 0!)
  if (!file->writable) return -1;
  1022ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1022ef:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  1022f3:	75 07                	jne    1022fc <fwrite+0x16>
  TODO();
}
  1022f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1022fa:	c9                   	leave  
  1022fb:	c3                   	ret    
  TODO();
  1022fc:	83 ec 04             	sub    $0x4,%esp
  1022ff:	68 db 40 10 00       	push   $0x1040db
  102304:	6a 3e                	push   $0x3e
  102306:	68 88 41 10 00       	push   $0x104188
  10230b:	e8 f0 ec ff ff       	call   101000 <abort>

00102310 <fseek>:

uint32_t fseek(file_t *file, uint32_t off, int whence) {
  102310:	55                   	push   %ebp
  102311:	89 e5                	mov    %esp,%ebp
  102313:	83 ec 08             	sub    $0x8,%esp
  // Lab3-1, change file's offset, do not let it cross file's size
  if (file->type == TYPE_FILE) {
  102316:	8b 45 08             	mov    0x8(%ebp),%eax
  102319:	83 38 01             	cmpl   $0x1,(%eax)
  10231c:	74 07                	je     102325 <fseek+0x15>
    TODO();
  }
  return -1;
}
  10231e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  102323:	c9                   	leave  
  102324:	c3                   	ret    
    TODO();
  102325:	83 ec 04             	sub    $0x4,%esp
  102328:	68 db 40 10 00       	push   $0x1040db
  10232d:	6a 44                	push   $0x44
  10232f:	68 88 41 10 00       	push   $0x104188
  102334:	e8 c7 ec ff ff       	call   101000 <abort>

00102339 <fdup>:

file_t *fdup(file_t *file) {
  102339:	55                   	push   %ebp
  10233a:	89 e5                	mov    %esp,%ebp
  10233c:	83 ec 0c             	sub    $0xc,%esp
  // Lab3-1, inc file's ref, then return itself
  TODO();
  10233f:	68 db 40 10 00       	push   $0x1040db
  102344:	6a 4b                	push   $0x4b
  102346:	68 88 41 10 00       	push   $0x104188
  10234b:	e8 b0 ec ff ff       	call   101000 <abort>

00102350 <fclose>:
}

void fclose(file_t *file) {
  102350:	55                   	push   %ebp
  102351:	89 e5                	mov    %esp,%ebp
  102353:	83 ec 0c             	sub    $0xc,%esp
  // Lab3-1, dec file's ref, if ref==0 and it's a file, call iclose
  TODO();
  102356:	68 db 40 10 00       	push   $0x1040db
  10235b:	6a 50                	push   $0x50
  10235d:	68 88 41 10 00       	push   $0x104188
  102362:	e8 99 ec ff ff       	call   101000 <abort>

00102367 <read_disk>:

static inline void wait_disk() {
  while ((inb(0x1f7) & 0xc0) != 0x40);
}

void read_disk(void *buf, int sect) {
  102367:	55                   	push   %ebp
  102368:	89 e5                	mov    %esp,%ebp
  10236a:	53                   	push   %ebx
  10236b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10236e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102371:	ba f7 01 00 00       	mov    $0x1f7,%edx
  102376:	ec                   	in     (%dx),%al
  while ((inb(0x1f7) & 0xc0) != 0x40);
  102377:	83 e0 c0             	and    $0xffffffc0,%eax
  10237a:	3c 40                	cmp    $0x40,%al
  10237c:	75 f8                	jne    102376 <read_disk+0xf>
  asm volatile ("outb %%al, %%dx" : : "a"(data), "d"((uint16_t)port));
  10237e:	b0 01                	mov    $0x1,%al
  102380:	ba f2 01 00 00       	mov    $0x1f2,%edx
  102385:	ee                   	out    %al,(%dx)
  102386:	ba f3 01 00 00       	mov    $0x1f3,%edx
  10238b:	88 c8                	mov    %cl,%al
  10238d:	ee                   	out    %al,(%dx)
  wait_disk();
  outb(0x1f2, 1);
  outb(0x1f3, sect);
  outb(0x1f4, sect >> 8);
  10238e:	89 c8                	mov    %ecx,%eax
  102390:	c1 f8 08             	sar    $0x8,%eax
  102393:	ba f4 01 00 00       	mov    $0x1f4,%edx
  102398:	ee                   	out    %al,(%dx)
  outb(0x1f5, sect >> 16);
  102399:	89 c8                	mov    %ecx,%eax
  10239b:	c1 f8 10             	sar    $0x10,%eax
  10239e:	ba f5 01 00 00       	mov    $0x1f5,%edx
  1023a3:	ee                   	out    %al,(%dx)
  outb(0x1f6, (sect >> 24) | 0xE0);
  1023a4:	89 c8                	mov    %ecx,%eax
  1023a6:	c1 f8 18             	sar    $0x18,%eax
  1023a9:	83 c8 e0             	or     $0xffffffe0,%eax
  1023ac:	ba f6 01 00 00       	mov    $0x1f6,%edx
  1023b1:	ee                   	out    %al,(%dx)
  1023b2:	b0 20                	mov    $0x20,%al
  1023b4:	ba f7 01 00 00       	mov    $0x1f7,%edx
  1023b9:	ee                   	out    %al,(%dx)
  asm volatile ("inb %1, %0" : "=a"(data) : "d"((uint16_t)port));
  1023ba:	ec                   	in     (%dx),%al
  while ((inb(0x1f7) & 0xc0) != 0x40);
  1023bb:	83 e0 c0             	and    $0xffffffc0,%eax
  1023be:	3c 40                	cmp    $0x40,%al
  1023c0:	75 f8                	jne    1023ba <read_disk+0x53>
  1023c2:	89 d9                	mov    %ebx,%ecx
  1023c4:	81 c3 00 02 00 00    	add    $0x200,%ebx
  asm volatile ("inl %1, %0" : "=a"(data) : "d"((uint16_t)port));
  1023ca:	ba f0 01 00 00       	mov    $0x1f0,%edx
  1023cf:	ed                   	in     (%dx),%eax
  outb(0x1f7, 0x20);
  wait_disk();
  for (int i = 0; i < SECTSIZE / 4; i ++) {
    ((uint32_t *)buf)[i] = inl(0x1f0);
  1023d0:	89 01                	mov    %eax,(%ecx)
  for (int i = 0; i < SECTSIZE / 4; i ++) {
  1023d2:	83 c1 04             	add    $0x4,%ecx
  1023d5:	39 d9                	cmp    %ebx,%ecx
  1023d7:	75 f6                	jne    1023cf <read_disk+0x68>
  }
}
  1023d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1023dc:	c9                   	leave  
  1023dd:	c3                   	ret    

001023de <write_disk>:

void write_disk(const void *buf, int sect) {
  1023de:	55                   	push   %ebp
  1023df:	89 e5                	mov    %esp,%ebp
  1023e1:	53                   	push   %ebx
  1023e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1023e5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  asm volatile ("inb %1, %0" : "=a"(data) : "d"((uint16_t)port));
  1023e8:	ba f7 01 00 00       	mov    $0x1f7,%edx
  1023ed:	ec                   	in     (%dx),%al
  while ((inb(0x1f7) & 0xc0) != 0x40);
  1023ee:	83 e0 c0             	and    $0xffffffc0,%eax
  1023f1:	3c 40                	cmp    $0x40,%al
  1023f3:	75 f8                	jne    1023ed <write_disk+0xf>
  asm volatile ("outb %%al, %%dx" : : "a"(data), "d"((uint16_t)port));
  1023f5:	b0 01                	mov    $0x1,%al
  1023f7:	ba f2 01 00 00       	mov    $0x1f2,%edx
  1023fc:	ee                   	out    %al,(%dx)
  1023fd:	ba f3 01 00 00       	mov    $0x1f3,%edx
  102402:	88 c8                	mov    %cl,%al
  102404:	ee                   	out    %al,(%dx)
  wait_disk();
  outb(0x1f2, 1);
  outb(0x1f3, sect);
  outb(0x1f4, sect >> 8);
  102405:	89 c8                	mov    %ecx,%eax
  102407:	c1 f8 08             	sar    $0x8,%eax
  10240a:	ba f4 01 00 00       	mov    $0x1f4,%edx
  10240f:	ee                   	out    %al,(%dx)
  outb(0x1f5, sect >> 16);
  102410:	89 c8                	mov    %ecx,%eax
  102412:	c1 f8 10             	sar    $0x10,%eax
  102415:	ba f5 01 00 00       	mov    $0x1f5,%edx
  10241a:	ee                   	out    %al,(%dx)
  outb(0x1f6, (sect >> 24) | 0xE0);
  10241b:	89 c8                	mov    %ecx,%eax
  10241d:	c1 f8 18             	sar    $0x18,%eax
  102420:	83 c8 e0             	or     $0xffffffe0,%eax
  102423:	ba f6 01 00 00       	mov    $0x1f6,%edx
  102428:	ee                   	out    %al,(%dx)
  102429:	b0 30                	mov    $0x30,%al
  10242b:	ba f7 01 00 00       	mov    $0x1f7,%edx
  102430:	ee                   	out    %al,(%dx)
  asm volatile ("inb %1, %0" : "=a"(data) : "d"((uint16_t)port));
  102431:	ec                   	in     (%dx),%al
  while ((inb(0x1f7) & 0xc0) != 0x40);
  102432:	83 e0 c0             	and    $0xffffffc0,%eax
  102435:	3c 40                	cmp    $0x40,%al
  102437:	75 f8                	jne    102431 <write_disk+0x53>
  102439:	89 d9                	mov    %ebx,%ecx
  10243b:	81 c3 00 02 00 00    	add    $0x200,%ebx
  asm volatile ("outl %%eax, %%dx" : : "a"(data), "d"((uint16_t)port));
  102441:	ba f0 01 00 00       	mov    $0x1f0,%edx
  102446:	8b 01                	mov    (%ecx),%eax
  102448:	ef                   	out    %eax,(%dx)
  outb(0x1f7, 0x30);
  wait_disk();
  for (int i = 0; i < SECTSIZE / 4; i ++) {
  102449:	83 c1 04             	add    $0x4,%ecx
  10244c:	39 d9                	cmp    %ebx,%ecx
  10244e:	75 f6                	jne    102446 <write_disk+0x68>
    outl(0x1f0, ((uint32_t *)buf)[i]);
  }
}
  102450:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102453:	c9                   	leave  
  102454:	c3                   	ret    

00102455 <copy_from_disk>:

void copy_from_disk(void *buf, int nbytes, int disk_offset) {
  102455:	55                   	push   %ebp
  102456:	89 e5                	mov    %esp,%ebp
  102458:	57                   	push   %edi
  102459:	56                   	push   %esi
  10245a:	53                   	push   %ebx
  10245b:	83 ec 0c             	sub    $0xc,%esp
  10245e:	8b 45 08             	mov    0x8(%ebp),%eax
  102461:	8b 55 10             	mov    0x10(%ebp),%edx
  uint32_t cur  = (uint32_t)buf;
  102464:	89 c3                	mov    %eax,%ebx
  uint32_t ed   = (uint32_t)buf + nbytes;
  102466:	89 c7                	mov    %eax,%edi
  102468:	03 7d 0c             	add    0xc(%ebp),%edi
  uint32_t sect = (disk_offset / SECTSIZE);
  10246b:	89 d6                	mov    %edx,%esi
  10246d:	85 d2                	test   %edx,%edx
  10246f:	78 27                	js     102498 <copy_from_disk+0x43>
  102471:	c1 fe 09             	sar    $0x9,%esi
  for(; cur < ed; cur += SECTSIZE, sect ++)
  102474:	39 f8                	cmp    %edi,%eax
  102476:	73 18                	jae    102490 <copy_from_disk+0x3b>
    read_disk((void *)cur, sect);
  102478:	83 ec 08             	sub    $0x8,%esp
  10247b:	56                   	push   %esi
  10247c:	53                   	push   %ebx
  10247d:	e8 e5 fe ff ff       	call   102367 <read_disk>
  for(; cur < ed; cur += SECTSIZE, sect ++)
  102482:	81 c3 00 02 00 00    	add    $0x200,%ebx
  102488:	46                   	inc    %esi
  102489:	83 c4 10             	add    $0x10,%esp
  10248c:	39 df                	cmp    %ebx,%edi
  10248e:	77 e8                	ja     102478 <copy_from_disk+0x23>
}
  102490:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102493:	5b                   	pop    %ebx
  102494:	5e                   	pop    %esi
  102495:	5f                   	pop    %edi
  102496:	5d                   	pop    %ebp
  102497:	c3                   	ret    
  uint32_t sect = (disk_offset / SECTSIZE);
  102498:	8d b2 ff 01 00 00    	lea    0x1ff(%edx),%esi
  10249e:	eb d1                	jmp    102471 <copy_from_disk+0x1c>

001024a0 <bgetcache>:
  uint8_t buf[BLK_SIZE];
} bcache_t;

static bcache_t blk_cache[BCACHE_NUM];

static bcache_t *bgetcache(uint32_t no) {
  1024a0:	55                   	push   %ebp
  1024a1:	89 e5                	mov    %esp,%ebp
  1024a3:	57                   	push   %edi
  1024a4:	56                   	push   %esi
  1024a5:	53                   	push   %ebx
  1024a6:	83 ec 0c             	sub    $0xc,%esp
  1024a9:	89 c6                	mov    %eax,%esi
  bcache_t *bc = &blk_cache[no % BCACHE_NUM];
  1024ab:	89 c3                	mov    %eax,%ebx
  1024ad:	83 e3 0f             	and    $0xf,%ebx
  1024b0:	89 d8                	mov    %ebx,%eax
  1024b2:	c1 e0 09             	shl    $0x9,%eax
  1024b5:	01 d8                	add    %ebx,%eax
  1024b7:	c1 e0 03             	shl    $0x3,%eax
  1024ba:	8d b8 a0 bf 12 00    	lea    0x12bfa0(%eax),%edi
  if (bc->valid == 0 || bc->no != no) {
  1024c0:	83 b8 a0 bf 12 00 00 	cmpl   $0x0,0x12bfa0(%eax)
  1024c7:	74 10                	je     1024d9 <bgetcache+0x39>
  1024c9:	89 da                	mov    %ebx,%edx
  1024cb:	c1 e2 09             	shl    $0x9,%edx
  1024ce:	01 da                	add    %ebx,%edx
  1024d0:	39 34 d5 a4 bf 12 00 	cmp    %esi,0x12bfa4(,%edx,8)
  1024d7:	74 36                	je     10250f <bgetcache+0x6f>
    copy_from_disk(bc->buf, BLK_SIZE, no * BLK_SIZE);
  1024d9:	83 ec 04             	sub    $0x4,%esp
  1024dc:	89 f2                	mov    %esi,%edx
  1024de:	c1 e2 0c             	shl    $0xc,%edx
  1024e1:	52                   	push   %edx
  1024e2:	68 00 10 00 00       	push   $0x1000
  1024e7:	05 a8 bf 12 00       	add    $0x12bfa8,%eax
  1024ec:	50                   	push   %eax
  1024ed:	e8 63 ff ff ff       	call   102455 <copy_from_disk>
    bc->valid = 1;
  1024f2:	89 d8                	mov    %ebx,%eax
  1024f4:	c1 e0 09             	shl    $0x9,%eax
  1024f7:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  1024fa:	c7 04 d5 a0 bf 12 00 	movl   $0x1,0x12bfa0(,%edx,8)
  102501:	01 00 00 00 
    bc->no = no;
  102505:	89 34 d5 a4 bf 12 00 	mov    %esi,0x12bfa4(,%edx,8)
  10250c:	83 c4 10             	add    $0x10,%esp
  }
  return bc;
}
  10250f:	89 f8                	mov    %edi,%eax
  102511:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102514:	5b                   	pop    %ebx
  102515:	5e                   	pop    %esi
  102516:	5f                   	pop    %edi
  102517:	5d                   	pop    %ebp
  102518:	c3                   	ret    

00102519 <copy_to_disk>:
void copy_to_disk(const void *buf, int nbytes, int disk_offset) {
  102519:	55                   	push   %ebp
  10251a:	89 e5                	mov    %esp,%ebp
  10251c:	57                   	push   %edi
  10251d:	56                   	push   %esi
  10251e:	53                   	push   %ebx
  10251f:	83 ec 0c             	sub    $0xc,%esp
  102522:	8b 45 08             	mov    0x8(%ebp),%eax
  102525:	8b 55 10             	mov    0x10(%ebp),%edx
  uint32_t cur  = (uint32_t)buf;
  102528:	89 c3                	mov    %eax,%ebx
  uint32_t ed   = (uint32_t)buf + nbytes;
  10252a:	89 c7                	mov    %eax,%edi
  10252c:	03 7d 0c             	add    0xc(%ebp),%edi
  uint32_t sect = (disk_offset / SECTSIZE);
  10252f:	89 d6                	mov    %edx,%esi
  102531:	85 d2                	test   %edx,%edx
  102533:	78 27                	js     10255c <copy_to_disk+0x43>
  102535:	c1 fe 09             	sar    $0x9,%esi
  for(; cur < ed; cur += SECTSIZE, sect ++)
  102538:	39 f8                	cmp    %edi,%eax
  10253a:	73 18                	jae    102554 <copy_to_disk+0x3b>
    write_disk((const void *)cur, sect);
  10253c:	83 ec 08             	sub    $0x8,%esp
  10253f:	56                   	push   %esi
  102540:	53                   	push   %ebx
  102541:	e8 98 fe ff ff       	call   1023de <write_disk>
  for(; cur < ed; cur += SECTSIZE, sect ++)
  102546:	81 c3 00 02 00 00    	add    $0x200,%ebx
  10254c:	46                   	inc    %esi
  10254d:	83 c4 10             	add    $0x10,%esp
  102550:	39 df                	cmp    %ebx,%edi
  102552:	77 e8                	ja     10253c <copy_to_disk+0x23>
}
  102554:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102557:	5b                   	pop    %ebx
  102558:	5e                   	pop    %esi
  102559:	5f                   	pop    %edi
  10255a:	5d                   	pop    %ebp
  10255b:	c3                   	ret    
  uint32_t sect = (disk_offset / SECTSIZE);
  10255c:	8d b2 ff 01 00 00    	lea    0x1ff(%edx),%esi
  102562:	eb d1                	jmp    102535 <copy_to_disk+0x1c>

00102564 <bread>:

void bread(void *dst, uint32_t size, uint32_t no, uint32_t off) {
  102564:	55                   	push   %ebp
  102565:	89 e5                	mov    %esp,%ebp
  102567:	56                   	push   %esi
  102568:	53                   	push   %ebx
  102569:	8b 75 0c             	mov    0xc(%ebp),%esi
  10256c:	8b 5d 14             	mov    0x14(%ebp),%ebx
  // read blk no's [off, off+size) to dst, promise off+size<=BLK_SIZE
  assert(size + off <= BLK_SIZE);
  10256f:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
  102572:	3d 00 10 00 00       	cmp    $0x1000,%eax
  102577:	77 23                	ja     10259c <bread+0x38>
  bcache_t *bc = bgetcache(no);
  102579:	8b 45 10             	mov    0x10(%ebp),%eax
  10257c:	e8 1f ff ff ff       	call   1024a0 <bgetcache>
  memcpy(dst, &bc->buf[off], size);
  102581:	83 ec 04             	sub    $0x4,%esp
  102584:	56                   	push   %esi
  102585:	8d 44 03 08          	lea    0x8(%ebx,%eax,1),%eax
  102589:	50                   	push   %eax
  10258a:	ff 75 08             	push   0x8(%ebp)
  10258d:	e8 af 12 00 00       	call   103841 <memcpy>
}
  102592:	83 c4 10             	add    $0x10,%esp
  102595:	8d 65 f8             	lea    -0x8(%ebp),%esp
  102598:	5b                   	pop    %ebx
  102599:	5e                   	pop    %esi
  10259a:	5d                   	pop    %ebp
  10259b:	c3                   	ret    
  assert(size + off <= BLK_SIZE);
  10259c:	83 ec 04             	sub    $0x4,%esp
  10259f:	68 9a 41 10 00       	push   $0x10419a
  1025a4:	6a 49                	push   $0x49
  1025a6:	68 b1 41 10 00       	push   $0x1041b1
  1025ab:	e8 50 ea ff ff       	call   101000 <abort>

001025b0 <bwrite>:

void bwrite(const void *src, uint32_t size, uint32_t no, uint32_t off) {
  1025b0:	55                   	push   %ebp
  1025b1:	89 e5                	mov    %esp,%ebp
  1025b3:	57                   	push   %edi
  1025b4:	56                   	push   %esi
  1025b5:	53                   	push   %ebx
  1025b6:	83 ec 0c             	sub    $0xc,%esp
  1025b9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1025bc:	8b 75 14             	mov    0x14(%ebp),%esi
  // write src to blk no's [off, off+size), promise off+size<=BLK_SIZE
  assert(size + off <= BLK_SIZE);
  1025bf:	8d 04 37             	lea    (%edi,%esi,1),%eax
  1025c2:	3d 00 10 00 00       	cmp    $0x1000,%eax
  1025c7:	77 3e                	ja     102607 <bwrite+0x57>
  bcache_t *bc = bgetcache(no);
  1025c9:	8b 45 10             	mov    0x10(%ebp),%eax
  1025cc:	e8 cf fe ff ff       	call   1024a0 <bgetcache>
  1025d1:	89 c3                	mov    %eax,%ebx
  memcpy(&bc->buf[off], src, size);
  1025d3:	83 ec 04             	sub    $0x4,%esp
  1025d6:	57                   	push   %edi
  1025d7:	ff 75 08             	push   0x8(%ebp)
  1025da:	8d 44 30 08          	lea    0x8(%eax,%esi,1),%eax
  1025de:	50                   	push   %eax
  1025df:	e8 5d 12 00 00       	call   103841 <memcpy>
  copy_to_disk(bc->buf, BLK_SIZE, no * BLK_SIZE);
  1025e4:	83 c4 0c             	add    $0xc,%esp
  1025e7:	8b 45 10             	mov    0x10(%ebp),%eax
  1025ea:	c1 e0 0c             	shl    $0xc,%eax
  1025ed:	50                   	push   %eax
  1025ee:	68 00 10 00 00       	push   $0x1000
  1025f3:	83 c3 08             	add    $0x8,%ebx
  1025f6:	53                   	push   %ebx
  1025f7:	e8 1d ff ff ff       	call   102519 <copy_to_disk>
}
  1025fc:	83 c4 10             	add    $0x10,%esp
  1025ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102602:	5b                   	pop    %ebx
  102603:	5e                   	pop    %esi
  102604:	5f                   	pop    %edi
  102605:	5d                   	pop    %ebp
  102606:	c3                   	ret    
  assert(size + off <= BLK_SIZE);
  102607:	83 ec 04             	sub    $0x4,%esp
  10260a:	68 9a 41 10 00       	push   $0x10419a
  10260f:	6a 50                	push   $0x50
  102611:	68 b1 41 10 00       	push   $0x1041b1
  102616:	e8 e5 e9 ff ff       	call   101000 <abort>

0010261b <bzero>:

void bzero(uint32_t no) {
  10261b:	55                   	push   %ebp
  10261c:	89 e5                	mov    %esp,%ebp
  10261e:	53                   	push   %ebx
  10261f:	83 ec 04             	sub    $0x4,%esp
  bcache_t *bc = bgetcache(no);
  102622:	8b 45 08             	mov    0x8(%ebp),%eax
  102625:	e8 76 fe ff ff       	call   1024a0 <bgetcache>
  memset(bc->buf, 0, BLK_SIZE);
  10262a:	8d 58 08             	lea    0x8(%eax),%ebx
  10262d:	83 ec 04             	sub    $0x4,%esp
  102630:	68 00 10 00 00       	push   $0x1000
  102635:	6a 00                	push   $0x0
  102637:	53                   	push   %ebx
  102638:	e8 c1 11 00 00       	call   1037fe <memset>
  copy_to_disk(bc->buf, BLK_SIZE, no * BLK_SIZE);
  10263d:	83 c4 0c             	add    $0xc,%esp
  102640:	8b 45 08             	mov    0x8(%ebp),%eax
  102643:	c1 e0 0c             	shl    $0xc,%eax
  102646:	50                   	push   %eax
  102647:	68 00 10 00 00       	push   $0x1000
  10264c:	53                   	push   %ebx
  10264d:	e8 c7 fe ff ff       	call   102519 <copy_to_disk>
}
  102652:	83 c4 10             	add    $0x10,%esp
  102655:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102658:	c9                   	leave  
  102659:	c3                   	ret    

0010265a <init_user_and_go>:
  init_user_and_go();
  panic("should never come back");
}

void init_user_and_go()
{
  10265a:	55                   	push   %ebp
  10265b:	89 e5                	mov    %esp,%ebp
  10265d:	56                   	push   %esi
  10265e:	53                   	push   %ebx
  // lab1-2:将名字为name的用户程序加载到内存，返回其入口地址（或-1如果不存在这个用户程序），第一个参数现在没有意义
  /*uint32_t eip = load_elf(NULL, "loaduser");
  assert(eip != -1);
  ((void (*)())eip)();*/
  // lab1-4:
  PD *pgdir = vm_alloc();
  10265f:	e8 b5 f0 ff ff       	call   101719 <vm_alloc>
  102664:	89 c3                	mov    %eax,%ebx
  Log("vm_alloc success\n");
  102666:	83 ec 04             	sub    $0x4,%esp
  102669:	6a 2b                	push   $0x2b
  10266b:	68 c3 41 10 00       	push   $0x1041c3
  102670:	68 d5 41 10 00       	push   $0x1041d5
  102675:	e8 42 eb ff ff       	call   1011bc <printf>
  uint32_t eip = load_elf(pgdir, "loaduser");
  10267a:	83 c4 08             	add    $0x8,%esp
  10267d:	68 ef 41 10 00       	push   $0x1041ef
  102682:	53                   	push   %ebx
  102683:	e8 1b f6 ff ff       	call   101ca3 <load_elf>
  102688:	89 c6                	mov    %eax,%esi
  Log("load_elf success\n");
  10268a:	83 c4 0c             	add    $0xc,%esp
  10268d:	6a 2d                	push   $0x2d
  10268f:	68 c3 41 10 00       	push   $0x1041c3
  102694:	68 f8 41 10 00       	push   $0x1041f8
  102699:	e8 1e eb ff ff       	call   1011bc <printf>
  assert(eip != -1);
  10269e:	83 c4 10             	add    $0x10,%esp
  1026a1:	83 fe ff             	cmp    $0xffffffff,%esi
  1026a4:	74 48                	je     1026ee <init_user_and_go+0x94>
  asm volatile ("mov %0, %%cr3" : : "r"(pdir));
  1026a6:	0f 22 db             	mov    %ebx,%cr3
  set_cr3(pgdir);
  Log("set_cr3 success\n");
  1026a9:	83 ec 04             	sub    $0x4,%esp
  1026ac:	6a 30                	push   $0x30
  1026ae:	68 c3 41 10 00       	push   $0x1041c3
  1026b3:	68 1c 42 10 00       	push   $0x10421c
  1026b8:	e8 ff ea ff ff       	call   1011bc <printf>
    "+m"(*addr), "=a"(result) : "1"(newval) : "cc", "memory");
  return result;
}

static inline void stack_switch_call(void *sp, void *entry, uintptr_t arg) {
  asm volatile (
  1026bd:	bb e8 ff ff bf       	mov    $0xbfffffe8,%ebx
  1026c2:	b8 00 00 00 00       	mov    $0x0,%eax
  1026c7:	89 f2                	mov    %esi,%edx
  1026c9:	89 dc                	mov    %ebx,%esp
  1026cb:	89 43 04             	mov    %eax,0x4(%ebx)
  1026ce:	ff e2                	jmp    *%edx
  stack_switch_call((void *)(USR_MEM - 16), (void *)eip, 0);
  Log("stackxxx success\n");
  1026d0:	83 c4 0c             	add    $0xc,%esp
  1026d3:	6a 32                	push   $0x32
  1026d5:	68 c3 41 10 00       	push   $0x1041c3
  1026da:	68 35 42 10 00       	push   $0x104235
  1026df:	e8 d8 ea ff ff       	call   1011bc <printf>
}
  1026e4:	83 c4 10             	add    $0x10,%esp
  1026e7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1026ea:	5b                   	pop    %ebx
  1026eb:	5e                   	pop    %esi
  1026ec:	5d                   	pop    %ebp
  1026ed:	c3                   	ret    
  assert(eip != -1);
  1026ee:	83 ec 04             	sub    $0x4,%esp
  1026f1:	68 12 42 10 00       	push   $0x104212
  1026f6:	6a 2e                	push   $0x2e
  1026f8:	68 c3 41 10 00       	push   $0x1041c3
  1026fd:	e8 fe e8 ff ff       	call   101000 <abort>

00102702 <main>:
{
  102702:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  102706:	83 e4 f0             	and    $0xfffffff0,%esp
  102709:	ff 71 fc             	push   -0x4(%ecx)
  10270c:	55                   	push   %ebp
  10270d:	89 e5                	mov    %esp,%ebp
  10270f:	51                   	push   %ecx
  102710:	83 ec 04             	sub    $0x4,%esp
  init_gdt();
  102713:	e8 d4 ed ff ff       	call   1014ec <init_gdt>
  init_serial();
  102718:	e8 93 f8 ff ff       	call   101fb0 <init_serial>
  init_fs();
  10271d:	e8 1c eb ff ff       	call   10123e <init_fs>
  init_page(); // uncomment me at Lab1-4
  102722:	e8 eb ee ff ff       	call   101612 <init_page>
  printf("Hello from OS!\n");
  102727:	83 ec 0c             	sub    $0xc,%esp
  10272a:	68 4f 42 10 00       	push   $0x10424f
  10272f:	e8 88 ea ff ff       	call   1011bc <printf>
  init_user_and_go();
  102734:	e8 21 ff ff ff       	call   10265a <init_user_and_go>
  panic("should never come back");
  102739:	83 c4 0c             	add    $0xc,%esp
  10273c:	68 5f 42 10 00       	push   $0x10425f
  102741:	6a 19                	push   $0x19
  102743:	68 c3 41 10 00       	push   $0x1041c3
  102748:	e8 b3 e8 ff ff       	call   101000 <abort>

0010274d <init_cte>:
  outb(PORT_PIC_SLAVE + 1, 2);
  outb(PORT_PIC_MASTER + 1, 0x3);
  outb(PORT_PIC_SLAVE + 1, 0x3);
}

void init_cte() {
  10274d:	55                   	push   %ebp
  10274e:	89 e5                	mov    %esp,%ebp
  102750:	53                   	push   %ebx
  for (int i = 0; i < NR_IRQ; i ++) {
    idt[i]  = GATE32(STS_IG, KSEL(SEG_KCODE), irqall, DPL_KERN);
  102751:	ba f0 2e 10 00       	mov    $0x102ef0,%edx
  102756:	c1 ea 10             	shr    $0x10,%edx
  for (int i = 0; i < NR_IRQ; i ++) {
  102759:	b8 00 00 00 00       	mov    $0x0,%eax
    idt[i]  = GATE32(STS_IG, KSEL(SEG_KCODE), irqall, DPL_KERN);
  10275e:	b9 f0 2e 10 00       	mov    $0x102ef0,%ecx
  102763:	66 89 0c c5 40 c0 13 	mov    %cx,0x13c040(,%eax,8)
  10276a:	00 
  10276b:	66 c7 04 c5 42 c0 13 	movw   $0x8,0x13c042(,%eax,8)
  102772:	00 08 00 
  102775:	c6 04 c5 44 c0 13 00 	movb   $0x0,0x13c044(,%eax,8)
  10277c:	00 
  10277d:	c6 04 c5 45 c0 13 00 	movb   $0x8e,0x13c045(,%eax,8)
  102784:	8e 
  102785:	66 89 14 c5 46 c0 13 	mov    %dx,0x13c046(,%eax,8)
  10278c:	00 
  for (int i = 0; i < NR_IRQ; i ++) {
  10278d:	40                   	inc    %eax
  10278e:	3d 00 01 00 00       	cmp    $0x100,%eax
  102793:	75 ce                	jne    102763 <init_cte+0x16>
  }
  idt[0] = GATE32(STS_IG, KSEL(SEG_KCODE), irq0, DPL_KERN);
  102795:	b8 06 2e 10 00       	mov    $0x102e06,%eax
  10279a:	66 a3 40 c0 13 00    	mov    %ax,0x13c040
  1027a0:	66 c7 05 42 c0 13 00 	movw   $0x8,0x13c042
  1027a7:	08 00 
  1027a9:	c6 05 44 c0 13 00 00 	movb   $0x0,0x13c044
  1027b0:	c6 05 45 c0 13 00 8e 	movb   $0x8e,0x13c045
  1027b7:	c1 e8 10             	shr    $0x10,%eax
  1027ba:	66 a3 46 c0 13 00    	mov    %ax,0x13c046
  idt[1] = GATE32(STS_IG, KSEL(SEG_KCODE), irq1, DPL_KERN);
  1027c0:	b8 0f 2e 10 00       	mov    $0x102e0f,%eax
  1027c5:	66 a3 48 c0 13 00    	mov    %ax,0x13c048
  1027cb:	66 c7 05 4a c0 13 00 	movw   $0x8,0x13c04a
  1027d2:	08 00 
  1027d4:	c6 05 4c c0 13 00 00 	movb   $0x0,0x13c04c
  1027db:	c6 05 4d c0 13 00 8e 	movb   $0x8e,0x13c04d
  1027e2:	c1 e8 10             	shr    $0x10,%eax
  1027e5:	66 a3 4e c0 13 00    	mov    %ax,0x13c04e
  idt[2] = GATE32(STS_IG, KSEL(SEG_KCODE), irq2, DPL_KERN);
  1027eb:	b8 18 2e 10 00       	mov    $0x102e18,%eax
  1027f0:	66 a3 50 c0 13 00    	mov    %ax,0x13c050
  1027f6:	66 c7 05 52 c0 13 00 	movw   $0x8,0x13c052
  1027fd:	08 00 
  1027ff:	c6 05 54 c0 13 00 00 	movb   $0x0,0x13c054
  102806:	c6 05 55 c0 13 00 8e 	movb   $0x8e,0x13c055
  10280d:	c1 e8 10             	shr    $0x10,%eax
  102810:	66 a3 56 c0 13 00    	mov    %ax,0x13c056
  idt[3] = GATE32(STS_IG, KSEL(SEG_KCODE), irq3, DPL_KERN);
  102816:	b8 21 2e 10 00       	mov    $0x102e21,%eax
  10281b:	66 a3 58 c0 13 00    	mov    %ax,0x13c058
  102821:	66 c7 05 5a c0 13 00 	movw   $0x8,0x13c05a
  102828:	08 00 
  10282a:	c6 05 5c c0 13 00 00 	movb   $0x0,0x13c05c
  102831:	c6 05 5d c0 13 00 8e 	movb   $0x8e,0x13c05d
  102838:	c1 e8 10             	shr    $0x10,%eax
  10283b:	66 a3 5e c0 13 00    	mov    %ax,0x13c05e
  idt[4] = GATE32(STS_IG, KSEL(SEG_KCODE), irq4, DPL_KERN);
  102841:	b8 2a 2e 10 00       	mov    $0x102e2a,%eax
  102846:	66 a3 60 c0 13 00    	mov    %ax,0x13c060
  10284c:	66 c7 05 62 c0 13 00 	movw   $0x8,0x13c062
  102853:	08 00 
  102855:	c6 05 64 c0 13 00 00 	movb   $0x0,0x13c064
  10285c:	c6 05 65 c0 13 00 8e 	movb   $0x8e,0x13c065
  102863:	c1 e8 10             	shr    $0x10,%eax
  102866:	66 a3 66 c0 13 00    	mov    %ax,0x13c066
  idt[5] = GATE32(STS_IG, KSEL(SEG_KCODE), irq5, DPL_KERN);
  10286c:	b8 33 2e 10 00       	mov    $0x102e33,%eax
  102871:	66 a3 68 c0 13 00    	mov    %ax,0x13c068
  102877:	66 c7 05 6a c0 13 00 	movw   $0x8,0x13c06a
  10287e:	08 00 
  102880:	c6 05 6c c0 13 00 00 	movb   $0x0,0x13c06c
  102887:	c6 05 6d c0 13 00 8e 	movb   $0x8e,0x13c06d
  10288e:	c1 e8 10             	shr    $0x10,%eax
  102891:	66 a3 6e c0 13 00    	mov    %ax,0x13c06e
  idt[6] = GATE32(STS_IG, KSEL(SEG_KCODE), irq6, DPL_KERN);
  102897:	b8 3c 2e 10 00       	mov    $0x102e3c,%eax
  10289c:	66 a3 70 c0 13 00    	mov    %ax,0x13c070
  1028a2:	66 c7 05 72 c0 13 00 	movw   $0x8,0x13c072
  1028a9:	08 00 
  1028ab:	c6 05 74 c0 13 00 00 	movb   $0x0,0x13c074
  1028b2:	c6 05 75 c0 13 00 8e 	movb   $0x8e,0x13c075
  1028b9:	c1 e8 10             	shr    $0x10,%eax
  1028bc:	66 a3 76 c0 13 00    	mov    %ax,0x13c076
  idt[7] = GATE32(STS_IG, KSEL(SEG_KCODE), irq7, DPL_KERN);
  1028c2:	b8 45 2e 10 00       	mov    $0x102e45,%eax
  1028c7:	66 a3 78 c0 13 00    	mov    %ax,0x13c078
  1028cd:	66 c7 05 7a c0 13 00 	movw   $0x8,0x13c07a
  1028d4:	08 00 
  1028d6:	c6 05 7c c0 13 00 00 	movb   $0x0,0x13c07c
  1028dd:	c6 05 7d c0 13 00 8e 	movb   $0x8e,0x13c07d
  1028e4:	c1 e8 10             	shr    $0x10,%eax
  1028e7:	66 a3 7e c0 13 00    	mov    %ax,0x13c07e
  idt[8] = GATE32(STS_IG, KSEL(SEG_KCODE), irq8, DPL_KERN);
  1028ed:	b8 4e 2e 10 00       	mov    $0x102e4e,%eax
  1028f2:	66 a3 80 c0 13 00    	mov    %ax,0x13c080
  1028f8:	66 c7 05 82 c0 13 00 	movw   $0x8,0x13c082
  1028ff:	08 00 
  102901:	c6 05 84 c0 13 00 00 	movb   $0x0,0x13c084
  102908:	c6 05 85 c0 13 00 8e 	movb   $0x8e,0x13c085
  10290f:	c1 e8 10             	shr    $0x10,%eax
  102912:	66 a3 86 c0 13 00    	mov    %ax,0x13c086
  idt[9] = GATE32(STS_IG, KSEL(SEG_KCODE), irq9, DPL_KERN);
  102918:	b8 55 2e 10 00       	mov    $0x102e55,%eax
  10291d:	66 a3 88 c0 13 00    	mov    %ax,0x13c088
  102923:	66 c7 05 8a c0 13 00 	movw   $0x8,0x13c08a
  10292a:	08 00 
  10292c:	c6 05 8c c0 13 00 00 	movb   $0x0,0x13c08c
  102933:	c6 05 8d c0 13 00 8e 	movb   $0x8e,0x13c08d
  10293a:	c1 e8 10             	shr    $0x10,%eax
  10293d:	66 a3 8e c0 13 00    	mov    %ax,0x13c08e
  idt[10] = GATE32(STS_IG, KSEL(SEG_KCODE), irq10, DPL_KERN);
  102943:	b8 5e 2e 10 00       	mov    $0x102e5e,%eax
  102948:	66 a3 90 c0 13 00    	mov    %ax,0x13c090
  10294e:	66 c7 05 92 c0 13 00 	movw   $0x8,0x13c092
  102955:	08 00 
  102957:	c6 05 94 c0 13 00 00 	movb   $0x0,0x13c094
  10295e:	c6 05 95 c0 13 00 8e 	movb   $0x8e,0x13c095
  102965:	c1 e8 10             	shr    $0x10,%eax
  102968:	66 a3 96 c0 13 00    	mov    %ax,0x13c096
  idt[11] = GATE32(STS_IG, KSEL(SEG_KCODE), irq11, DPL_KERN);
  10296e:	b8 65 2e 10 00       	mov    $0x102e65,%eax
  102973:	66 a3 98 c0 13 00    	mov    %ax,0x13c098
  102979:	66 c7 05 9a c0 13 00 	movw   $0x8,0x13c09a
  102980:	08 00 
  102982:	c6 05 9c c0 13 00 00 	movb   $0x0,0x13c09c
  102989:	c6 05 9d c0 13 00 8e 	movb   $0x8e,0x13c09d
  102990:	c1 e8 10             	shr    $0x10,%eax
  102993:	66 a3 9e c0 13 00    	mov    %ax,0x13c09e
  idt[12] = GATE32(STS_IG, KSEL(SEG_KCODE), irq12, DPL_KERN);
  102999:	b8 6c 2e 10 00       	mov    $0x102e6c,%eax
  10299e:	66 a3 a0 c0 13 00    	mov    %ax,0x13c0a0
  1029a4:	66 c7 05 a2 c0 13 00 	movw   $0x8,0x13c0a2
  1029ab:	08 00 
  1029ad:	c6 05 a4 c0 13 00 00 	movb   $0x0,0x13c0a4
  1029b4:	c6 05 a5 c0 13 00 8e 	movb   $0x8e,0x13c0a5
  1029bb:	c1 e8 10             	shr    $0x10,%eax
  1029be:	66 a3 a6 c0 13 00    	mov    %ax,0x13c0a6
  idt[13] = GATE32(STS_IG, KSEL(SEG_KCODE), irq13, DPL_KERN);
  1029c4:	b8 73 2e 10 00       	mov    $0x102e73,%eax
  1029c9:	66 a3 a8 c0 13 00    	mov    %ax,0x13c0a8
  1029cf:	66 c7 05 aa c0 13 00 	movw   $0x8,0x13c0aa
  1029d6:	08 00 
  1029d8:	c6 05 ac c0 13 00 00 	movb   $0x0,0x13c0ac
  1029df:	c6 05 ad c0 13 00 8e 	movb   $0x8e,0x13c0ad
  1029e6:	c1 e8 10             	shr    $0x10,%eax
  1029e9:	66 a3 ae c0 13 00    	mov    %ax,0x13c0ae
  idt[14] = GATE32(STS_IG, KSEL(SEG_KCODE), irq14, DPL_KERN);
  1029ef:	b8 77 2e 10 00       	mov    $0x102e77,%eax
  1029f4:	66 a3 b0 c0 13 00    	mov    %ax,0x13c0b0
  1029fa:	66 c7 05 b2 c0 13 00 	movw   $0x8,0x13c0b2
  102a01:	08 00 
  102a03:	c6 05 b4 c0 13 00 00 	movb   $0x0,0x13c0b4
  102a0a:	c6 05 b5 c0 13 00 8e 	movb   $0x8e,0x13c0b5
  102a11:	c1 e8 10             	shr    $0x10,%eax
  102a14:	66 a3 b6 c0 13 00    	mov    %ax,0x13c0b6
  idt[15] = GATE32(STS_IG, KSEL(SEG_KCODE), irq15, DPL_KERN);
  102a1a:	b8 7b 2e 10 00       	mov    $0x102e7b,%eax
  102a1f:	66 a3 b8 c0 13 00    	mov    %ax,0x13c0b8
  102a25:	66 c7 05 ba c0 13 00 	movw   $0x8,0x13c0ba
  102a2c:	08 00 
  102a2e:	c6 05 bc c0 13 00 00 	movb   $0x0,0x13c0bc
  102a35:	c6 05 bd c0 13 00 8e 	movb   $0x8e,0x13c0bd
  102a3c:	c1 e8 10             	shr    $0x10,%eax
  102a3f:	66 a3 be c0 13 00    	mov    %ax,0x13c0be
  idt[16] = GATE32(STS_IG, KSEL(SEG_KCODE), irq16, DPL_KERN);
  102a45:	b8 81 2e 10 00       	mov    $0x102e81,%eax
  102a4a:	66 a3 c0 c0 13 00    	mov    %ax,0x13c0c0
  102a50:	66 c7 05 c2 c0 13 00 	movw   $0x8,0x13c0c2
  102a57:	08 00 
  102a59:	c6 05 c4 c0 13 00 00 	movb   $0x0,0x13c0c4
  102a60:	c6 05 c5 c0 13 00 8e 	movb   $0x8e,0x13c0c5
  102a67:	c1 e8 10             	shr    $0x10,%eax
  102a6a:	66 a3 c6 c0 13 00    	mov    %ax,0x13c0c6
  idt[32] = GATE32(STS_IG, KSEL(SEG_KCODE), irq32, DPL_KERN);
  102a70:	b8 87 2e 10 00       	mov    $0x102e87,%eax
  102a75:	66 a3 40 c1 13 00    	mov    %ax,0x13c140
  102a7b:	66 c7 05 42 c1 13 00 	movw   $0x8,0x13c142
  102a82:	08 00 
  102a84:	c6 05 44 c1 13 00 00 	movb   $0x0,0x13c144
  102a8b:	c6 05 45 c1 13 00 8e 	movb   $0x8e,0x13c145
  102a92:	c1 e8 10             	shr    $0x10,%eax
  102a95:	66 a3 46 c1 13 00    	mov    %ax,0x13c146
  idt[33] = GATE32(STS_IG, KSEL(SEG_KCODE), irq33, DPL_KERN);
  102a9b:	b8 8d 2e 10 00       	mov    $0x102e8d,%eax
  102aa0:	66 a3 48 c1 13 00    	mov    %ax,0x13c148
  102aa6:	66 c7 05 4a c1 13 00 	movw   $0x8,0x13c14a
  102aad:	08 00 
  102aaf:	c6 05 4c c1 13 00 00 	movb   $0x0,0x13c14c
  102ab6:	c6 05 4d c1 13 00 8e 	movb   $0x8e,0x13c14d
  102abd:	c1 e8 10             	shr    $0x10,%eax
  102ac0:	66 a3 4e c1 13 00    	mov    %ax,0x13c14e
  idt[34] = GATE32(STS_IG, KSEL(SEG_KCODE), irq34, DPL_KERN);
  102ac6:	b8 93 2e 10 00       	mov    $0x102e93,%eax
  102acb:	66 a3 50 c1 13 00    	mov    %ax,0x13c150
  102ad1:	66 c7 05 52 c1 13 00 	movw   $0x8,0x13c152
  102ad8:	08 00 
  102ada:	c6 05 54 c1 13 00 00 	movb   $0x0,0x13c154
  102ae1:	c6 05 55 c1 13 00 8e 	movb   $0x8e,0x13c155
  102ae8:	c1 e8 10             	shr    $0x10,%eax
  102aeb:	66 a3 56 c1 13 00    	mov    %ax,0x13c156
  idt[35] = GATE32(STS_IG, KSEL(SEG_KCODE), irq35, DPL_KERN);
  102af1:	b8 99 2e 10 00       	mov    $0x102e99,%eax
  102af6:	66 a3 58 c1 13 00    	mov    %ax,0x13c158
  102afc:	66 c7 05 5a c1 13 00 	movw   $0x8,0x13c15a
  102b03:	08 00 
  102b05:	c6 05 5c c1 13 00 00 	movb   $0x0,0x13c15c
  102b0c:	c6 05 5d c1 13 00 8e 	movb   $0x8e,0x13c15d
  102b13:	c1 e8 10             	shr    $0x10,%eax
  102b16:	66 a3 5e c1 13 00    	mov    %ax,0x13c15e
  idt[36] = GATE32(STS_IG, KSEL(SEG_KCODE), irq36, DPL_KERN);
  102b1c:	b8 9f 2e 10 00       	mov    $0x102e9f,%eax
  102b21:	66 a3 60 c1 13 00    	mov    %ax,0x13c160
  102b27:	66 c7 05 62 c1 13 00 	movw   $0x8,0x13c162
  102b2e:	08 00 
  102b30:	c6 05 64 c1 13 00 00 	movb   $0x0,0x13c164
  102b37:	c6 05 65 c1 13 00 8e 	movb   $0x8e,0x13c165
  102b3e:	c1 e8 10             	shr    $0x10,%eax
  102b41:	66 a3 66 c1 13 00    	mov    %ax,0x13c166
  idt[37] = GATE32(STS_IG, KSEL(SEG_KCODE), irq37, DPL_KERN);
  102b47:	b8 a5 2e 10 00       	mov    $0x102ea5,%eax
  102b4c:	66 a3 68 c1 13 00    	mov    %ax,0x13c168
  102b52:	66 c7 05 6a c1 13 00 	movw   $0x8,0x13c16a
  102b59:	08 00 
  102b5b:	c6 05 6c c1 13 00 00 	movb   $0x0,0x13c16c
  102b62:	c6 05 6d c1 13 00 8e 	movb   $0x8e,0x13c16d
  102b69:	c1 e8 10             	shr    $0x10,%eax
  102b6c:	66 a3 6e c1 13 00    	mov    %ax,0x13c16e
  idt[38] = GATE32(STS_IG, KSEL(SEG_KCODE), irq38, DPL_KERN);
  102b72:	b8 ab 2e 10 00       	mov    $0x102eab,%eax
  102b77:	66 a3 70 c1 13 00    	mov    %ax,0x13c170
  102b7d:	66 c7 05 72 c1 13 00 	movw   $0x8,0x13c172
  102b84:	08 00 
  102b86:	c6 05 74 c1 13 00 00 	movb   $0x0,0x13c174
  102b8d:	c6 05 75 c1 13 00 8e 	movb   $0x8e,0x13c175
  102b94:	c1 e8 10             	shr    $0x10,%eax
  102b97:	66 a3 76 c1 13 00    	mov    %ax,0x13c176
  idt[39] = GATE32(STS_IG, KSEL(SEG_KCODE), irq39, DPL_KERN);
  102b9d:	b8 b1 2e 10 00       	mov    $0x102eb1,%eax
  102ba2:	66 a3 78 c1 13 00    	mov    %ax,0x13c178
  102ba8:	66 c7 05 7a c1 13 00 	movw   $0x8,0x13c17a
  102baf:	08 00 
  102bb1:	c6 05 7c c1 13 00 00 	movb   $0x0,0x13c17c
  102bb8:	c6 05 7d c1 13 00 8e 	movb   $0x8e,0x13c17d
  102bbf:	c1 e8 10             	shr    $0x10,%eax
  102bc2:	66 a3 7e c1 13 00    	mov    %ax,0x13c17e
  idt[40] = GATE32(STS_IG, KSEL(SEG_KCODE), irq40, DPL_KERN);
  102bc8:	b8 b7 2e 10 00       	mov    $0x102eb7,%eax
  102bcd:	66 a3 80 c1 13 00    	mov    %ax,0x13c180
  102bd3:	66 c7 05 82 c1 13 00 	movw   $0x8,0x13c182
  102bda:	08 00 
  102bdc:	c6 05 84 c1 13 00 00 	movb   $0x0,0x13c184
  102be3:	c6 05 85 c1 13 00 8e 	movb   $0x8e,0x13c185
  102bea:	c1 e8 10             	shr    $0x10,%eax
  102bed:	66 a3 86 c1 13 00    	mov    %ax,0x13c186
  idt[41] = GATE32(STS_IG, KSEL(SEG_KCODE), irq41, DPL_KERN);
  102bf3:	b8 bd 2e 10 00       	mov    $0x102ebd,%eax
  102bf8:	66 a3 88 c1 13 00    	mov    %ax,0x13c188
  102bfe:	66 c7 05 8a c1 13 00 	movw   $0x8,0x13c18a
  102c05:	08 00 
  102c07:	c6 05 8c c1 13 00 00 	movb   $0x0,0x13c18c
  102c0e:	c6 05 8d c1 13 00 8e 	movb   $0x8e,0x13c18d
  102c15:	c1 e8 10             	shr    $0x10,%eax
  102c18:	66 a3 8e c1 13 00    	mov    %ax,0x13c18e
  idt[42] = GATE32(STS_IG, KSEL(SEG_KCODE), irq42, DPL_KERN);
  102c1e:	b8 c3 2e 10 00       	mov    $0x102ec3,%eax
  102c23:	66 a3 90 c1 13 00    	mov    %ax,0x13c190
  102c29:	66 c7 05 92 c1 13 00 	movw   $0x8,0x13c192
  102c30:	08 00 
  102c32:	c6 05 94 c1 13 00 00 	movb   $0x0,0x13c194
  102c39:	c6 05 95 c1 13 00 8e 	movb   $0x8e,0x13c195
  102c40:	c1 e8 10             	shr    $0x10,%eax
  102c43:	66 a3 96 c1 13 00    	mov    %ax,0x13c196
  idt[43] = GATE32(STS_IG, KSEL(SEG_KCODE), irq43, DPL_KERN);
  102c49:	b8 c9 2e 10 00       	mov    $0x102ec9,%eax
  102c4e:	66 a3 98 c1 13 00    	mov    %ax,0x13c198
  102c54:	66 c7 05 9a c1 13 00 	movw   $0x8,0x13c19a
  102c5b:	08 00 
  102c5d:	c6 05 9c c1 13 00 00 	movb   $0x0,0x13c19c
  102c64:	c6 05 9d c1 13 00 8e 	movb   $0x8e,0x13c19d
  102c6b:	c1 e8 10             	shr    $0x10,%eax
  102c6e:	66 a3 9e c1 13 00    	mov    %ax,0x13c19e
  idt[44] = GATE32(STS_IG, KSEL(SEG_KCODE), irq44, DPL_KERN);
  102c74:	b8 cf 2e 10 00       	mov    $0x102ecf,%eax
  102c79:	66 a3 a0 c1 13 00    	mov    %ax,0x13c1a0
  102c7f:	66 c7 05 a2 c1 13 00 	movw   $0x8,0x13c1a2
  102c86:	08 00 
  102c88:	c6 05 a4 c1 13 00 00 	movb   $0x0,0x13c1a4
  102c8f:	c6 05 a5 c1 13 00 8e 	movb   $0x8e,0x13c1a5
  102c96:	c1 e8 10             	shr    $0x10,%eax
  102c99:	66 a3 a6 c1 13 00    	mov    %ax,0x13c1a6
  idt[45] = GATE32(STS_IG, KSEL(SEG_KCODE), irq45, DPL_KERN);
  102c9f:	b8 d5 2e 10 00       	mov    $0x102ed5,%eax
  102ca4:	66 a3 a8 c1 13 00    	mov    %ax,0x13c1a8
  102caa:	66 c7 05 aa c1 13 00 	movw   $0x8,0x13c1aa
  102cb1:	08 00 
  102cb3:	c6 05 ac c1 13 00 00 	movb   $0x0,0x13c1ac
  102cba:	c6 05 ad c1 13 00 8e 	movb   $0x8e,0x13c1ad
  102cc1:	c1 e8 10             	shr    $0x10,%eax
  102cc4:	66 a3 ae c1 13 00    	mov    %ax,0x13c1ae
  idt[46] = GATE32(STS_IG, KSEL(SEG_KCODE), irq46, DPL_KERN);
  102cca:	b8 db 2e 10 00       	mov    $0x102edb,%eax
  102ccf:	66 a3 b0 c1 13 00    	mov    %ax,0x13c1b0
  102cd5:	66 c7 05 b2 c1 13 00 	movw   $0x8,0x13c1b2
  102cdc:	08 00 
  102cde:	c6 05 b4 c1 13 00 00 	movb   $0x0,0x13c1b4
  102ce5:	c6 05 b5 c1 13 00 8e 	movb   $0x8e,0x13c1b5
  102cec:	c1 e8 10             	shr    $0x10,%eax
  102cef:	66 a3 b6 c1 13 00    	mov    %ax,0x13c1b6
  idt[47] = GATE32(STS_IG, KSEL(SEG_KCODE), irq47, DPL_KERN);
  102cf5:	b8 e1 2e 10 00       	mov    $0x102ee1,%eax
  102cfa:	66 a3 b8 c1 13 00    	mov    %ax,0x13c1b8
  102d00:	66 c7 05 ba c1 13 00 	movw   $0x8,0x13c1ba
  102d07:	08 00 
  102d09:	c6 05 bc c1 13 00 00 	movb   $0x0,0x13c1bc
  102d10:	c6 05 bd c1 13 00 8e 	movb   $0x8e,0x13c1bd
  102d17:	c1 e8 10             	shr    $0x10,%eax
  102d1a:	66 a3 be c1 13 00    	mov    %ax,0x13c1be
  idt[128] = GATE32(STS_IG, KSEL(SEG_KCODE), irq128, DPL_USER);
  102d20:	b8 e7 2e 10 00       	mov    $0x102ee7,%eax
  102d25:	66 a3 40 c4 13 00    	mov    %ax,0x13c440
  102d2b:	66 c7 05 42 c4 13 00 	movw   $0x8,0x13c442
  102d32:	08 00 
  102d34:	c6 05 44 c4 13 00 00 	movb   $0x0,0x13c444
  102d3b:	c6 05 45 c4 13 00 ee 	movb   $0xee,0x13c445
  102d42:	c1 e8 10             	shr    $0x10,%eax
  102d45:	66 a3 46 c4 13 00    	mov    %ax,0x13c446
  data.size = size;
  102d4b:	66 c7 05 20 c0 13 00 	movw   $0x800,0x13c020
  102d52:	00 08 
  data.idt = idt;
  102d54:	c7 05 22 c0 13 00 40 	movl   $0x13c040,0x13c022
  102d5b:	c0 13 00 
  asm volatile ("lidt (%0)" : : "r"(&data));
  102d5e:	b8 20 c0 13 00       	mov    $0x13c020,%eax
  102d63:	0f 01 18             	lidtl  (%eax)
  asm volatile ("outb %%al, %%dx" : : "a"(data), "d"((uint16_t)port));
  102d66:	b0 11                	mov    $0x11,%al
  102d68:	ba 20 00 00 00       	mov    $0x20,%edx
  102d6d:	ee                   	out    %al,(%dx)
  102d6e:	ba a0 00 00 00       	mov    $0xa0,%edx
  102d73:	ee                   	out    %al,(%dx)
  102d74:	bb 21 00 00 00       	mov    $0x21,%ebx
  102d79:	b0 20                	mov    $0x20,%al
  102d7b:	89 da                	mov    %ebx,%edx
  102d7d:	ee                   	out    %al,(%dx)
  102d7e:	b9 a1 00 00 00       	mov    $0xa1,%ecx
  102d83:	b0 28                	mov    $0x28,%al
  102d85:	89 ca                	mov    %ecx,%edx
  102d87:	ee                   	out    %al,(%dx)
  102d88:	b0 04                	mov    $0x4,%al
  102d8a:	89 da                	mov    %ebx,%edx
  102d8c:	ee                   	out    %al,(%dx)
  102d8d:	b0 02                	mov    $0x2,%al
  102d8f:	89 ca                	mov    %ecx,%edx
  102d91:	ee                   	out    %al,(%dx)
  102d92:	b0 03                	mov    $0x3,%al
  102d94:	89 da                	mov    %ebx,%edx
  102d96:	ee                   	out    %al,(%dx)
  102d97:	89 ca                	mov    %ecx,%edx
  102d99:	ee                   	out    %al,(%dx)
  // TODO: Lab2-1 set idt[129]
  set_idt(idt, sizeof(idt));
  init_intr();
}
  102d9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102d9d:	c9                   	leave  
  102d9e:	c3                   	ret    

00102d9f <irq_handle>:

void irq_handle(Context *ctx) {
  102d9f:	55                   	push   %ebp
  102da0:	89 e5                	mov    %esp,%ebp
  102da2:	53                   	push   %ebx
  102da3:	83 ec 04             	sub    $0x4,%esp
  102da6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (ctx->irq <= 16) {
  102da9:	83 7b 2c 10          	cmpl   $0x10,0x2c(%ebx)
  102dad:	76 1f                	jbe    102dce <irq_handle+0x2f>
  }
  switch (ctx->irq) {
  // TODO: Lab1-5 handle pagefault and syscall
  // TODO: Lab1-7 handle serial and timer
  // TODO: Lab2-1 handle yield
  default: assert(ctx->irq >= T_IRQ0 && ctx->irq < T_IRQ0 + NR_INTR);
  102daf:	8b 43 2c             	mov    0x2c(%ebx),%eax
  102db2:	83 e8 20             	sub    $0x20,%eax
  102db5:	83 f8 0f             	cmp    $0xf,%eax
  102db8:	76 22                	jbe    102ddc <irq_handle+0x3d>
  102dba:	83 ec 04             	sub    $0x4,%esp
  102dbd:	68 78 42 10 00       	push   $0x104278
  102dc2:	6a 71                	push   $0x71
  102dc4:	68 aa 42 10 00       	push   $0x1042aa
  102dc9:	e8 32 e2 ff ff       	call   101000 <abort>
    exception_debug_handler(ctx);
  102dce:	83 ec 0c             	sub    $0xc,%esp
  102dd1:	53                   	push   %ebx
  102dd2:	e8 3e f4 ff ff       	call   102215 <exception_debug_handler>
  102dd7:	83 c4 10             	add    $0x10,%esp
  102dda:	eb d3                	jmp    102daf <irq_handle+0x10>
  }
  irq_iret(ctx);
  102ddc:	83 ec 0c             	sub    $0xc,%esp
  102ddf:	53                   	push   %ebx
  102de0:	e8 2c 01 00 00       	call   102f11 <irq_iret>

00102de5 <init_timer>:
  102de5:	b0 34                	mov    $0x34,%al
  102de7:	ba 43 00 00 00       	mov    $0x43,%edx
  102dec:	ee                   	out    %al,(%dx)
  102ded:	ba 40 00 00 00       	mov    $0x40,%edx
  102df2:	b0 9b                	mov    $0x9b,%al
  102df4:	ee                   	out    %al,(%dx)
  102df5:	b0 2e                	mov    $0x2e,%al
  102df7:	ee                   	out    %al,(%dx)
void init_timer() {
  int counter = FREQ_8253 / HZ;
  outb(TIMER_PORT + 3, 0x34);
  outb(TIMER_PORT + 0, counter % 256);
  outb(TIMER_PORT + 0, counter / 256);
}
  102df8:	c3                   	ret    

00102df9 <timer_handle>:

void timer_handle() {
  ++tick;
  102df9:	ff 05 40 c8 13 00    	incl   0x13c840
  //proc_yield(); // TODO: uncomment me in Lab2-1
}
  102dff:	c3                   	ret    

00102e00 <get_tick>:

uint32_t get_tick() {
  return tick;
}
  102e00:	a1 40 c8 13 00       	mov    0x13c840,%eax
  102e05:	c3                   	ret    

00102e06 <irq0>:
  102e06:	6a 00                	push   $0x0
  102e08:	6a 00                	push   $0x0
  102e0a:	e9 e7 00 00 00       	jmp    102ef6 <trap>

00102e0f <irq1>:
  102e0f:	6a 00                	push   $0x0
  102e11:	6a 01                	push   $0x1
  102e13:	e9 de 00 00 00       	jmp    102ef6 <trap>

00102e18 <irq2>:
  102e18:	6a 00                	push   $0x0
  102e1a:	6a 02                	push   $0x2
  102e1c:	e9 d5 00 00 00       	jmp    102ef6 <trap>

00102e21 <irq3>:
  102e21:	6a 00                	push   $0x0
  102e23:	6a 03                	push   $0x3
  102e25:	e9 cc 00 00 00       	jmp    102ef6 <trap>

00102e2a <irq4>:
  102e2a:	6a 00                	push   $0x0
  102e2c:	6a 04                	push   $0x4
  102e2e:	e9 c3 00 00 00       	jmp    102ef6 <trap>

00102e33 <irq5>:
  102e33:	6a 00                	push   $0x0
  102e35:	6a 05                	push   $0x5
  102e37:	e9 ba 00 00 00       	jmp    102ef6 <trap>

00102e3c <irq6>:
  102e3c:	6a 00                	push   $0x0
  102e3e:	6a 06                	push   $0x6
  102e40:	e9 b1 00 00 00       	jmp    102ef6 <trap>

00102e45 <irq7>:
  102e45:	6a 00                	push   $0x0
  102e47:	6a 07                	push   $0x7
  102e49:	e9 a8 00 00 00       	jmp    102ef6 <trap>

00102e4e <irq8>:
  102e4e:	6a 08                	push   $0x8
  102e50:	e9 a1 00 00 00       	jmp    102ef6 <trap>

00102e55 <irq9>:
  102e55:	6a 00                	push   $0x0
  102e57:	6a 09                	push   $0x9
  102e59:	e9 98 00 00 00       	jmp    102ef6 <trap>

00102e5e <irq10>:
  102e5e:	6a 0a                	push   $0xa
  102e60:	e9 91 00 00 00       	jmp    102ef6 <trap>

00102e65 <irq11>:
  102e65:	6a 0b                	push   $0xb
  102e67:	e9 8a 00 00 00       	jmp    102ef6 <trap>

00102e6c <irq12>:
  102e6c:	6a 0c                	push   $0xc
  102e6e:	e9 83 00 00 00       	jmp    102ef6 <trap>

00102e73 <irq13>:
  102e73:	6a 0d                	push   $0xd
  102e75:	eb 7f                	jmp    102ef6 <trap>

00102e77 <irq14>:
  102e77:	6a 0e                	push   $0xe
  102e79:	eb 7b                	jmp    102ef6 <trap>

00102e7b <irq15>:
  102e7b:	6a 00                	push   $0x0
  102e7d:	6a 0f                	push   $0xf
  102e7f:	eb 75                	jmp    102ef6 <trap>

00102e81 <irq16>:
  102e81:	6a 00                	push   $0x0
  102e83:	6a 10                	push   $0x10
  102e85:	eb 6f                	jmp    102ef6 <trap>

00102e87 <irq32>:
  102e87:	6a 00                	push   $0x0
  102e89:	6a 20                	push   $0x20
  102e8b:	eb 69                	jmp    102ef6 <trap>

00102e8d <irq33>:
  102e8d:	6a 00                	push   $0x0
  102e8f:	6a 21                	push   $0x21
  102e91:	eb 63                	jmp    102ef6 <trap>

00102e93 <irq34>:
  102e93:	6a 00                	push   $0x0
  102e95:	6a 22                	push   $0x22
  102e97:	eb 5d                	jmp    102ef6 <trap>

00102e99 <irq35>:
  102e99:	6a 00                	push   $0x0
  102e9b:	6a 23                	push   $0x23
  102e9d:	eb 57                	jmp    102ef6 <trap>

00102e9f <irq36>:
  102e9f:	6a 00                	push   $0x0
  102ea1:	6a 24                	push   $0x24
  102ea3:	eb 51                	jmp    102ef6 <trap>

00102ea5 <irq37>:
  102ea5:	6a 00                	push   $0x0
  102ea7:	6a 25                	push   $0x25
  102ea9:	eb 4b                	jmp    102ef6 <trap>

00102eab <irq38>:
  102eab:	6a 00                	push   $0x0
  102ead:	6a 26                	push   $0x26
  102eaf:	eb 45                	jmp    102ef6 <trap>

00102eb1 <irq39>:
  102eb1:	6a 00                	push   $0x0
  102eb3:	6a 27                	push   $0x27
  102eb5:	eb 3f                	jmp    102ef6 <trap>

00102eb7 <irq40>:
  102eb7:	6a 00                	push   $0x0
  102eb9:	6a 28                	push   $0x28
  102ebb:	eb 39                	jmp    102ef6 <trap>

00102ebd <irq41>:
  102ebd:	6a 00                	push   $0x0
  102ebf:	6a 29                	push   $0x29
  102ec1:	eb 33                	jmp    102ef6 <trap>

00102ec3 <irq42>:
  102ec3:	6a 00                	push   $0x0
  102ec5:	6a 2a                	push   $0x2a
  102ec7:	eb 2d                	jmp    102ef6 <trap>

00102ec9 <irq43>:
  102ec9:	6a 00                	push   $0x0
  102ecb:	6a 2b                	push   $0x2b
  102ecd:	eb 27                	jmp    102ef6 <trap>

00102ecf <irq44>:
  102ecf:	6a 00                	push   $0x0
  102ed1:	6a 2c                	push   $0x2c
  102ed3:	eb 21                	jmp    102ef6 <trap>

00102ed5 <irq45>:
  102ed5:	6a 00                	push   $0x0
  102ed7:	6a 2d                	push   $0x2d
  102ed9:	eb 1b                	jmp    102ef6 <trap>

00102edb <irq46>:
  102edb:	6a 00                	push   $0x0
  102edd:	6a 2e                	push   $0x2e
  102edf:	eb 15                	jmp    102ef6 <trap>

00102ee1 <irq47>:
  102ee1:	6a 00                	push   $0x0
  102ee3:	6a 2f                	push   $0x2f
  102ee5:	eb 0f                	jmp    102ef6 <trap>

00102ee7 <irq128>:
  102ee7:	6a 00                	push   $0x0
  102ee9:	68 80 00 00 00       	push   $0x80
  102eee:	eb 06                	jmp    102ef6 <trap>

00102ef0 <irqall>:
  102ef0:	6a 00                	push   $0x0
  102ef2:	6a ff                	push   $0xffffffff
  102ef4:	eb 00                	jmp    102ef6 <trap>

00102ef6 <trap>:
  102ef6:	50                   	push   %eax
  102ef7:	53                   	push   %ebx
  102ef8:	51                   	push   %ecx
  102ef9:	52                   	push   %edx
  102efa:	56                   	push   %esi
  102efb:	57                   	push   %edi
  102efc:	55                   	push   %ebp
  102efd:	66 8c d8             	mov    %ds,%ax
  102f00:	50                   	push   %eax
  102f01:	66 b8 10 00          	mov    $0x10,%ax
  102f05:	8e d8                	mov    %eax,%ds
  102f07:	8e c0                	mov    %eax,%es
  102f09:	54                   	push   %esp
  102f0a:	e8 90 fe ff ff       	call   102d9f <irq_handle>
  102f0f:	eb fe                	jmp    102f0f <trap+0x19>

00102f11 <irq_iret>:
  102f11:	8b 44 24 04          	mov    0x4(%esp),%eax
  102f15:	89 c4                	mov    %eax,%esp
  102f17:	58                   	pop    %eax
  102f18:	8e d8                	mov    %eax,%ds
  102f1a:	8e c0                	mov    %eax,%es
  102f1c:	5d                   	pop    %ebp
  102f1d:	5f                   	pop    %edi
  102f1e:	5e                   	pop    %esi
  102f1f:	5a                   	pop    %edx
  102f20:	59                   	pop    %ecx
  102f21:	5b                   	pop    %ebx
  102f22:	58                   	pop    %eax
  102f23:	83 c4 08             	add    $0x8,%esp
  102f26:	cf                   	iret   

00102f27 <number>:
  return i;
}

static char *
number(char *str, long num, int base, int size, int precision, int type)
{
  102f27:	55                   	push   %ebp
  102f28:	89 e5                	mov    %esp,%ebp
  102f2a:	57                   	push   %edi
  102f2b:	56                   	push   %esi
  102f2c:	53                   	push   %ebx
  102f2d:	83 ec 60             	sub    $0x60,%esp
  102f30:	89 c3                	mov    %eax,%ebx
  102f32:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  char  c, sign, tmp[66];
  char *dig = digits;
  int   i;

  if (type & UPPERCASE)
  102f35:	f6 45 10 40          	testb  $0x40,0x10(%ebp)
  102f39:	74 4d                	je     102f88 <number+0x61>
    dig = upper_digits;
  102f3b:	bf e4 42 10 00       	mov    $0x1042e4,%edi
  if (type & LEFT)
  102f40:	f6 45 10 10          	testb  $0x10,0x10(%ebp)
  102f44:	74 04                	je     102f4a <number+0x23>
    type &= ~ZEROPAD;
  102f46:	83 65 10 fe          	andl   $0xfffffffe,0x10(%ebp)
  if (base < 2 || base > 36)
  102f4a:	8b 45 9c             	mov    -0x64(%ebp),%eax
  102f4d:	89 c6                	mov    %eax,%esi
  102f4f:	83 e8 02             	sub    $0x2,%eax
  102f52:	83 f8 22             	cmp    $0x22,%eax
  102f55:	0f 87 da 01 00 00    	ja     103135 <number+0x20e>
    return 0;

  c    = (type & ZEROPAD) ? '0' : ' ';
  102f5b:	8b 45 10             	mov    0x10(%ebp),%eax
  102f5e:	83 e0 01             	and    $0x1,%eax
  102f61:	83 f8 01             	cmp    $0x1,%eax
  102f64:	19 c0                	sbb    %eax,%eax
  102f66:	83 e0 f0             	and    $0xfffffff0,%eax
  102f69:	83 c0 30             	add    $0x30,%eax
  102f6c:	88 45 96             	mov    %al,-0x6a(%ebp)
  sign = 0;
  if (type & SIGN)
  102f6f:	f6 45 10 02          	testb  $0x2,0x10(%ebp)
  102f73:	74 66                	je     102fdb <number+0xb4>
  {
    if (num < 0)
  102f75:	85 d2                	test   %edx,%edx
  102f77:	78 16                	js     102f8f <number+0x68>
    {
      sign = '-';
      num  = -num;
      size--;
    }
    else if (type & PLUS)
  102f79:	f6 45 10 04          	testb  $0x4,0x10(%ebp)
  102f7d:	74 49                	je     102fc8 <number+0xa1>
    {
      sign = '+';
      size--;
  102f7f:	ff 4d 08             	decl   0x8(%ebp)
      sign = '+';
  102f82:	c6 45 97 2b          	movb   $0x2b,-0x69(%ebp)
  102f86:	eb 57                	jmp    102fdf <number+0xb8>
  char *dig = digits;
  102f88:	bf bc 42 10 00       	mov    $0x1042bc,%edi
  102f8d:	eb b1                	jmp    102f40 <number+0x19>
      num  = -num;
  102f8f:	f7 da                	neg    %edx
      size--;
  102f91:	ff 4d 08             	decl   0x8(%ebp)
      sign = ' ';
      size--;
    }
  }

  if (type & HEX_PREP)
  102f94:	8b 45 10             	mov    0x10(%ebp),%eax
  102f97:	83 e0 20             	and    $0x20,%eax
  102f9a:	89 45 98             	mov    %eax,-0x68(%ebp)
  102f9d:	0f 85 49 01 00 00    	jne    1030ec <number+0x1c5>
      sign = '-';
  102fa3:	c6 45 97 2d          	movb   $0x2d,-0x69(%ebp)
      size -= 2;
    else if (base == 8)
      size--;
  }

  i = 0;
  102fa7:	b9 00 00 00 00       	mov    $0x0,%ecx
    tmp[i++] = '0';
  else
  {
    while (num != 0)
    {
      tmp[i++] = dig[((unsigned long)num) % (unsigned)base];
  102fac:	41                   	inc    %ecx
  102fad:	89 d0                	mov    %edx,%eax
  102faf:	ba 00 00 00 00       	mov    $0x0,%edx
  102fb4:	f7 f6                	div    %esi
  102fb6:	8a 14 17             	mov    (%edi,%edx,1),%dl
  102fb9:	88 55 a0             	mov    %dl,-0x60(%ebp)
  102fbc:	88 54 0d b1          	mov    %dl,-0x4f(%ebp,%ecx,1)
      num      = ((unsigned long)num) / (unsigned)base;
  102fc0:	89 c2                	mov    %eax,%edx
    while (num != 0)
  102fc2:	85 c0                	test   %eax,%eax
  102fc4:	75 e6                	jne    102fac <number+0x85>
  102fc6:	eb 43                	jmp    10300b <number+0xe4>
    else if (type & SPACE)
  102fc8:	f6 45 10 08          	testb  $0x8,0x10(%ebp)
  102fcc:	0f 84 11 01 00 00    	je     1030e3 <number+0x1bc>
      size--;
  102fd2:	ff 4d 08             	decl   0x8(%ebp)
      sign = ' ';
  102fd5:	c6 45 97 20          	movb   $0x20,-0x69(%ebp)
  102fd9:	eb 04                	jmp    102fdf <number+0xb8>
  sign = 0;
  102fdb:	c6 45 97 00          	movb   $0x0,-0x69(%ebp)
  if (type & HEX_PREP)
  102fdf:	8b 45 10             	mov    0x10(%ebp),%eax
  102fe2:	83 e0 20             	and    $0x20,%eax
  102fe5:	89 45 98             	mov    %eax,-0x68(%ebp)
  102fe8:	74 14                	je     102ffe <number+0xd7>
    if (base == 16)
  102fea:	83 7d 9c 10          	cmpl   $0x10,-0x64(%ebp)
  102fee:	0f 84 01 01 00 00    	je     1030f5 <number+0x1ce>
    else if (base == 8)
  102ff4:	83 7d 9c 08          	cmpl   $0x8,-0x64(%ebp)
  102ff8:	0f 84 00 01 00 00    	je     1030fe <number+0x1d7>
  if (num == 0)
  102ffe:	85 d2                	test   %edx,%edx
  103000:	75 a5                	jne    102fa7 <number+0x80>
    tmp[i++] = '0';
  103002:	c6 45 b2 30          	movb   $0x30,-0x4e(%ebp)
  103006:	b9 01 00 00 00       	mov    $0x1,%ecx
    }
  }

  if (i > precision)
  10300b:	89 c8                	mov    %ecx,%eax
  10300d:	3b 4d 0c             	cmp    0xc(%ebp),%ecx
  103010:	7d 03                	jge    103015 <number+0xee>
  103012:	8b 45 0c             	mov    0xc(%ebp),%eax
    precision = i;
  size -= precision;
  103015:	8b 75 08             	mov    0x8(%ebp),%esi
  103018:	29 c6                	sub    %eax,%esi
  if (!(type & (ZEROPAD | LEFT)))
  10301a:	f6 45 10 11          	testb  $0x11,0x10(%ebp)
  10301e:	75 1e                	jne    10303e <number+0x117>
    while (size-- > 0)
  103020:	8d 56 ff             	lea    -0x1(%esi),%edx
  103023:	85 f6                	test   %esi,%esi
  103025:	0f 8e db 00 00 00    	jle    103106 <number+0x1df>
  10302b:	8d 14 33             	lea    (%ebx,%esi,1),%edx
      *str++ = ' ';
  10302e:	43                   	inc    %ebx
  10302f:	c6 43 ff 20          	movb   $0x20,-0x1(%ebx)
    while (size-- > 0)
  103033:	39 d3                	cmp    %edx,%ebx
  103035:	75 f7                	jne    10302e <number+0x107>
      *str++ = ' ';
  103037:	89 d3                	mov    %edx,%ebx
    while (size-- > 0)
  103039:	be ff ff ff ff       	mov    $0xffffffff,%esi
  if (sign)
  10303e:	8a 55 97             	mov    -0x69(%ebp),%dl
  103041:	84 d2                	test   %dl,%dl
  103043:	74 05                	je     10304a <number+0x123>
    *str++ = sign;
  103045:	88 13                	mov    %dl,(%ebx)
  103047:	8d 5b 01             	lea    0x1(%ebx),%ebx

  if (type & HEX_PREP)
  10304a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
  10304e:	74 14                	je     103064 <number+0x13d>
  {
    if (base == 8)
  103050:	83 7d 9c 08          	cmpl   $0x8,-0x64(%ebp)
  103054:	0f 84 b3 00 00 00    	je     10310d <number+0x1e6>
      *str++ = '0';
    else if (base == 16)
  10305a:	83 7d 9c 10          	cmpl   $0x10,-0x64(%ebp)
  10305e:	0f 84 b4 00 00 00    	je     103118 <number+0x1f1>
      *str++ = '0';
      *str++ = digits[33];
    }
  }

  if (!(type & LEFT))
  103064:	f6 45 10 10          	testb  $0x10,0x10(%ebp)
  103068:	75 24                	jne    10308e <number+0x167>
    while (size-- > 0)
  10306a:	8d 56 ff             	lea    -0x1(%esi),%edx
  10306d:	85 f6                	test   %esi,%esi
  10306f:	0f 8e b2 00 00 00    	jle    103127 <number+0x200>
  103075:	8d 14 33             	lea    (%ebx,%esi,1),%edx
  103078:	89 c6                	mov    %eax,%esi
  10307a:	8a 45 96             	mov    -0x6a(%ebp),%al
      *str++ = c;
  10307d:	43                   	inc    %ebx
  10307e:	88 43 ff             	mov    %al,-0x1(%ebx)
    while (size-- > 0)
  103081:	39 d3                	cmp    %edx,%ebx
  103083:	75 f8                	jne    10307d <number+0x156>
      *str++ = c;
  103085:	89 f0                	mov    %esi,%eax
  103087:	89 d3                	mov    %edx,%ebx
    while (size-- > 0)
  103089:	be ff ff ff ff       	mov    $0xffffffff,%esi
  while (i < precision--)
  10308e:	39 c1                	cmp    %eax,%ecx
  103090:	0f 8d 98 00 00 00    	jge    10312e <number+0x207>
  103096:	29 c8                	sub    %ecx,%eax
  103098:	01 d8                	add    %ebx,%eax
    *str++ = '0';
  10309a:	43                   	inc    %ebx
  10309b:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
  while (i < precision--)
  10309f:	39 c3                	cmp    %eax,%ebx
  1030a1:	75 f7                	jne    10309a <number+0x173>
  while (i-- > 0)
  1030a3:	85 c9                	test   %ecx,%ecx
  1030a5:	7e 22                	jle    1030c9 <number+0x1a2>
  1030a7:	89 4d a0             	mov    %ecx,-0x60(%ebp)
  1030aa:	8d 5d b2             	lea    -0x4e(%ebp),%ebx
  1030ad:	8d 54 0d b1          	lea    -0x4f(%ebp,%ecx,1),%edx
  1030b1:	89 c1                	mov    %eax,%ecx
  1030b3:	89 45 9c             	mov    %eax,-0x64(%ebp)
    *str++ = tmp[i];
  1030b6:	41                   	inc    %ecx
  1030b7:	8a 02                	mov    (%edx),%al
  1030b9:	88 41 ff             	mov    %al,-0x1(%ecx)
  while (i-- > 0)
  1030bc:	89 d7                	mov    %edx,%edi
  1030be:	4a                   	dec    %edx
  1030bf:	39 df                	cmp    %ebx,%edi
  1030c1:	75 f3                	jne    1030b6 <number+0x18f>
    *str++ = tmp[i];
  1030c3:	8b 45 9c             	mov    -0x64(%ebp),%eax
  1030c6:	03 45 a0             	add    -0x60(%ebp),%eax
  while (size-- > 0)
  1030c9:	85 f6                	test   %esi,%esi
  1030cb:	7e 6f                	jle    10313c <number+0x215>
  1030cd:	8d 14 30             	lea    (%eax,%esi,1),%edx
    *str++ = ' ';
  1030d0:	40                   	inc    %eax
  1030d1:	c6 40 ff 20          	movb   $0x20,-0x1(%eax)
  while (size-- > 0)
  1030d5:	39 d0                	cmp    %edx,%eax
  1030d7:	75 f7                	jne    1030d0 <number+0x1a9>

  return str;
}
  1030d9:	89 d0                	mov    %edx,%eax
  1030db:	83 c4 60             	add    $0x60,%esp
  1030de:	5b                   	pop    %ebx
  1030df:	5e                   	pop    %esi
  1030e0:	5f                   	pop    %edi
  1030e1:	5d                   	pop    %ebp
  1030e2:	c3                   	ret    
  sign = 0;
  1030e3:	c6 45 97 00          	movb   $0x0,-0x69(%ebp)
  1030e7:	e9 f3 fe ff ff       	jmp    102fdf <number+0xb8>
      sign = '-';
  1030ec:	c6 45 97 2d          	movb   $0x2d,-0x69(%ebp)
  1030f0:	e9 f5 fe ff ff       	jmp    102fea <number+0xc3>
      size -= 2;
  1030f5:	83 6d 08 02          	subl   $0x2,0x8(%ebp)
  1030f9:	e9 00 ff ff ff       	jmp    102ffe <number+0xd7>
      size--;
  1030fe:	ff 4d 08             	decl   0x8(%ebp)
  103101:	e9 f8 fe ff ff       	jmp    102ffe <number+0xd7>
    while (size-- > 0)
  103106:	89 d6                	mov    %edx,%esi
  103108:	e9 31 ff ff ff       	jmp    10303e <number+0x117>
      *str++ = '0';
  10310d:	c6 03 30             	movb   $0x30,(%ebx)
  103110:	8d 5b 01             	lea    0x1(%ebx),%ebx
  103113:	e9 4c ff ff ff       	jmp    103064 <number+0x13d>
      *str++ = '0';
  103118:	c6 03 30             	movb   $0x30,(%ebx)
      *str++ = digits[33];
  10311b:	c6 43 01 78          	movb   $0x78,0x1(%ebx)
  10311f:	8d 5b 02             	lea    0x2(%ebx),%ebx
  103122:	e9 3d ff ff ff       	jmp    103064 <number+0x13d>
    while (size-- > 0)
  103127:	89 d6                	mov    %edx,%esi
  103129:	e9 60 ff ff ff       	jmp    10308e <number+0x167>
  while (i < precision--)
  10312e:	89 d8                	mov    %ebx,%eax
  103130:	e9 6e ff ff ff       	jmp    1030a3 <number+0x17c>
    return 0;
  103135:	ba 00 00 00 00       	mov    $0x0,%edx
  10313a:	eb 9d                	jmp    1030d9 <number+0x1b2>
  while (size-- > 0)
  10313c:	89 c2                	mov    %eax,%edx
  10313e:	eb 99                	jmp    1030d9 <number+0x1b2>

00103140 <vsprintf>:
  return str;
}

int
vsprintf(char *buf, const char *fmt, va_list args)
{
  103140:	55                   	push   %ebp
  103141:	89 e5                	mov    %esp,%ebp
  103143:	57                   	push   %edi
  103144:	56                   	push   %esi
  103145:	53                   	push   %ebx
  103146:	83 ec 4c             	sub    $0x4c,%esp
  103149:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  int field_width; // Width of output field
  int precision;   // Min. # of digits for integers; max number of chars for
           // from string
  int qualifier;   // 'h', 'l', or 'L' for integer fields

  for (str = buf; *fmt; fmt++)
  10314c:	8a 01                	mov    (%ecx),%al
  10314e:	84 c0                	test   %al,%al
  103150:	0f 84 17 06 00 00    	je     10376d <vsprintf+0x62d>
  103156:	8b 5d 08             	mov    0x8(%ebp),%ebx
        tmp[len++] = digits[n / 10];
  103159:	89 de                	mov    %ebx,%esi
  10315b:	e9 c9 05 00 00       	jmp    103729 <vsprintf+0x5e9>
      *str++ = *fmt;
      continue;
    }

    // Process flags
    flags = 0;
  103160:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  103167:	eb 06                	jmp    10316f <vsprintf+0x2f>
  repeat:
    fmt++; // This also skips first '%'
    switch (*fmt)
    {
      case '-':
        flags |= LEFT;
  103169:	83 4d c4 10          	orl    $0x10,-0x3c(%ebp)
    fmt++; // This also skips first '%'
  10316d:	89 c1                	mov    %eax,%ecx
  10316f:	8d 41 01             	lea    0x1(%ecx),%eax
    switch (*fmt)
  103172:	8a 51 01             	mov    0x1(%ecx),%dl
  103175:	8d 5a e0             	lea    -0x20(%edx),%ebx
  103178:	80 fb 10             	cmp    $0x10,%bl
  10317b:	77 22                	ja     10319f <vsprintf+0x5f>
  10317d:	0f b6 db             	movzbl %bl,%ebx
  103180:	ff 24 9d 10 43 10 00 	jmp    *0x104310(,%ebx,4)
        goto repeat;
      case '+':
        flags |= PLUS;
  103187:	83 4d c4 04          	orl    $0x4,-0x3c(%ebp)
        goto repeat;
  10318b:	eb e0                	jmp    10316d <vsprintf+0x2d>
      case ' ':
        flags |= SPACE;
  10318d:	83 4d c4 08          	orl    $0x8,-0x3c(%ebp)
        goto repeat;
  103191:	eb da                	jmp    10316d <vsprintf+0x2d>
      case '#':
        flags |= HEX_PREP;
  103193:	83 4d c4 20          	orl    $0x20,-0x3c(%ebp)
        goto repeat;
  103197:	eb d4                	jmp    10316d <vsprintf+0x2d>
      case '0':
        flags |= ZEROPAD;
  103199:	83 4d c4 01          	orl    $0x1,-0x3c(%ebp)
        goto repeat;
  10319d:	eb ce                	jmp    10316d <vsprintf+0x2d>
    }

    // Get field width
    field_width = -1;
    if (is_digit(*fmt))
  10319f:	8d 5a d0             	lea    -0x30(%edx),%ebx
  1031a2:	80 fb 09             	cmp    $0x9,%bl
  1031a5:	76 3c                	jbe    1031e3 <vsprintf+0xa3>
      field_width = skip_atoi(&fmt);
    else if (*fmt == '*')
  1031a7:	80 fa 2a             	cmp    $0x2a,%dl
  1031aa:	74 55                	je     103201 <vsprintf+0xc1>
    field_width = -1;
  1031ac:	bf ff ff ff ff       	mov    $0xffffffff,%edi
      }
    }

    // Get the precision
    precision = -1;
    if (*fmt == '.')
  1031b1:	80 38 2e             	cmpb   $0x2e,(%eax)
  1031b4:	74 6a                	je     103220 <vsprintf+0xe0>
    precision = -1;
  1031b6:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
        precision = 0;
    }

    // Get the conversion qualifier
    qualifier = -1;
    if (*fmt == 'l' || *fmt == 'L')
  1031bd:	8a 10                	mov    (%eax),%dl
  1031bf:	88 d1                	mov    %dl,%cl
  1031c1:	83 e1 df             	and    $0xffffffdf,%ecx
  1031c4:	80 f9 4c             	cmp    $0x4c,%cl
  1031c7:	0f 84 ba 00 00 00    	je     103287 <vsprintf+0x147>
    }

    // Default base
    base = 10;

    switch (*fmt)
  1031cd:	8d 4a bf             	lea    -0x41(%edx),%ecx
  1031d0:	80 f9 37             	cmp    $0x37,%cl
  1031d3:	0f 87 e5 04 00 00    	ja     1036be <vsprintf+0x57e>
  1031d9:	0f b6 c9             	movzbl %cl,%ecx
  1031dc:	ff 24 8d 54 43 10 00 	jmp    *0x104354(,%ecx,4)
  int i = 0;
  1031e3:	bf 00 00 00 00       	mov    $0x0,%edi
    i = i * 10 + *((*s)++) - '0';
  1031e8:	40                   	inc    %eax
  1031e9:	8d 0c bf             	lea    (%edi,%edi,4),%ecx
  1031ec:	01 c9                	add    %ecx,%ecx
  1031ee:	0f be d2             	movsbl %dl,%edx
  1031f1:	8d 7c 11 d0          	lea    -0x30(%ecx,%edx,1),%edi
  while (is_digit(**s))
  1031f5:	8a 10                	mov    (%eax),%dl
  1031f7:	8d 4a d0             	lea    -0x30(%edx),%ecx
  1031fa:	80 f9 09             	cmp    $0x9,%cl
  1031fd:	76 e9                	jbe    1031e8 <vsprintf+0xa8>
  1031ff:	eb b0                	jmp    1031b1 <vsprintf+0x71>
      fmt++;
  103201:	8d 41 02             	lea    0x2(%ecx),%eax
      field_width = va_arg(args, int);
  103204:	8b 7d 10             	mov    0x10(%ebp),%edi
  103207:	8d 57 04             	lea    0x4(%edi),%edx
  10320a:	8b 3f                	mov    (%edi),%edi
      if (field_width < 0)
  10320c:	85 ff                	test   %edi,%edi
  10320e:	78 05                	js     103215 <vsprintf+0xd5>
      field_width = va_arg(args, int);
  103210:	89 55 10             	mov    %edx,0x10(%ebp)
  103213:	eb 9c                	jmp    1031b1 <vsprintf+0x71>
        field_width = -field_width;
  103215:	f7 df                	neg    %edi
        flags |= LEFT;
  103217:	83 4d c4 10          	orl    $0x10,-0x3c(%ebp)
      field_width = va_arg(args, int);
  10321b:	89 55 10             	mov    %edx,0x10(%ebp)
  10321e:	eb 91                	jmp    1031b1 <vsprintf+0x71>
      ++fmt;
  103220:	8d 48 01             	lea    0x1(%eax),%ecx
      if (is_digit(*fmt))
  103223:	8a 50 01             	mov    0x1(%eax),%dl
  103226:	8d 5a d0             	lea    -0x30(%edx),%ebx
  103229:	80 fb 09             	cmp    $0x9,%bl
  10322c:	76 13                	jbe    103241 <vsprintf+0x101>
      else if (*fmt == '*')
  10322e:	80 fa 2a             	cmp    $0x2a,%dl
  103231:	74 38                	je     10326b <vsprintf+0x12b>
      ++fmt;
  103233:	89 c8                	mov    %ecx,%eax
        precision = 0;
  103235:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  10323c:	e9 7c ff ff ff       	jmp    1031bd <vsprintf+0x7d>
  int i = 0;
  103241:	b8 00 00 00 00       	mov    $0x0,%eax
    i = i * 10 + *((*s)++) - '0';
  103246:	41                   	inc    %ecx
  103247:	8d 04 80             	lea    (%eax,%eax,4),%eax
  10324a:	01 c0                	add    %eax,%eax
  10324c:	0f be d2             	movsbl %dl,%edx
  10324f:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
  while (is_digit(**s))
  103253:	8a 11                	mov    (%ecx),%dl
  103255:	8d 5a d0             	lea    -0x30(%edx),%ebx
  103258:	80 fb 09             	cmp    $0x9,%bl
  10325b:	76 e9                	jbe    103246 <vsprintf+0x106>
      if (precision < 0)
  10325d:	89 45 c0             	mov    %eax,-0x40(%ebp)
  103260:	85 c0                	test   %eax,%eax
  103262:	78 1a                	js     10327e <vsprintf+0x13e>
  103264:	89 c8                	mov    %ecx,%eax
  103266:	e9 52 ff ff ff       	jmp    1031bd <vsprintf+0x7d>
        ++fmt;
  10326b:	8d 48 02             	lea    0x2(%eax),%ecx
        precision = va_arg(args, int);
  10326e:	8b 45 10             	mov    0x10(%ebp),%eax
  103271:	8b 00                	mov    (%eax),%eax
  103273:	8b 5d 10             	mov    0x10(%ebp),%ebx
  103276:	8d 5b 04             	lea    0x4(%ebx),%ebx
  103279:	89 5d 10             	mov    %ebx,0x10(%ebp)
  10327c:	eb df                	jmp    10325d <vsprintf+0x11d>
  10327e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  103285:	eb dd                	jmp    103264 <vsprintf+0x124>
      qualifier = *fmt;
  103287:	0f be ca             	movsbl %dl,%ecx
      fmt++;
  10328a:	8d 58 01             	lea    0x1(%eax),%ebx
    switch (*fmt)
  10328d:	8a 50 01             	mov    0x1(%eax),%dl
  103290:	8d 42 bf             	lea    -0x41(%edx),%eax
  103293:	3c 37                	cmp    $0x37,%al
  103295:	0f 87 25 04 00 00    	ja     1036c0 <vsprintf+0x580>
  10329b:	0f b6 c0             	movzbl %al,%eax
  10329e:	ff 24 85 34 44 10 00 	jmp    *0x104434(,%eax,4)
  1032a5:	89 c3                	mov    %eax,%ebx
  1032a7:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx

      case 'X':
        flags |= UPPERCASE;

      case 'x':
        base = 16;
  1032ac:	b8 10 00 00 00       	mov    $0x10,%eax
        else
          --fmt;
        continue;
    }

    if (qualifier == 'l')
  1032b1:	83 f9 6c             	cmp    $0x6c,%ecx
  1032b4:	0f 84 3f 04 00 00    	je     1036f9 <vsprintf+0x5b9>
      num = va_arg(args, unsigned long);
    else if (flags & SIGN)
  1032ba:	f6 45 c4 02          	testb  $0x2,-0x3c(%ebp)
  1032be:	0f 84 76 04 00 00    	je     10373a <vsprintf+0x5fa>
      num = va_arg(args, int);
  1032c4:	8b 55 10             	mov    0x10(%ebp),%edx
  1032c7:	8b 12                	mov    (%edx),%edx
  1032c9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1032cc:	8d 49 04             	lea    0x4(%ecx),%ecx
  1032cf:	89 4d 10             	mov    %ecx,0x10(%ebp)
  1032d2:	e9 30 04 00 00       	jmp    103707 <vsprintf+0x5c7>
    switch (*fmt)
  1032d7:	89 c3                	mov    %eax,%ebx
        if (!(flags & LEFT))
  1032d9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  1032dc:	83 e2 10             	and    $0x10,%edx
  1032df:	74 30                	je     103311 <vsprintf+0x1d1>
        *str++ = (unsigned char)va_arg(args, int);
  1032e1:	8b 45 10             	mov    0x10(%ebp),%eax
  1032e4:	8d 50 04             	lea    0x4(%eax),%edx
  1032e7:	8d 46 01             	lea    0x1(%esi),%eax
  1032ea:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1032ed:	8b 09                	mov    (%ecx),%ecx
  1032ef:	88 0e                	mov    %cl,(%esi)
        while (--field_width > 0)
  1032f1:	83 ff 01             	cmp    $0x1,%edi
  1032f4:	0f 8e 50 04 00 00    	jle    10374a <vsprintf+0x60a>
  1032fa:	89 f9                	mov    %edi,%ecx
  1032fc:	01 f7                	add    %esi,%edi
          *str++ = ' ';
  1032fe:	40                   	inc    %eax
  1032ff:	c6 40 ff 20          	movb   $0x20,-0x1(%eax)
        while (--field_width > 0)
  103303:	39 f8                	cmp    %edi,%eax
  103305:	75 f7                	jne    1032fe <vsprintf+0x1be>
          *str++ = ' ';
  103307:	01 ce                	add    %ecx,%esi
        *str++ = (unsigned char)va_arg(args, int);
  103309:	89 55 10             	mov    %edx,0x10(%ebp)
  10330c:	e9 0e 04 00 00       	jmp    10371f <vsprintf+0x5df>
          while (--field_width > 0)
  103311:	8d 47 ff             	lea    -0x1(%edi),%eax
  103314:	85 c0                	test   %eax,%eax
  103316:	7e 13                	jle    10332b <vsprintf+0x1eb>
  103318:	8d 44 3e ff          	lea    -0x1(%esi,%edi,1),%eax
            *str++ = ' ';
  10331c:	46                   	inc    %esi
  10331d:	c6 46 ff 20          	movb   $0x20,-0x1(%esi)
          while (--field_width > 0)
  103321:	39 c6                	cmp    %eax,%esi
  103323:	75 f7                	jne    10331c <vsprintf+0x1dc>
  103325:	89 d7                	mov    %edx,%edi
            *str++ = ' ';
  103327:	89 c6                	mov    %eax,%esi
  103329:	eb b6                	jmp    1032e1 <vsprintf+0x1a1>
          while (--field_width > 0)
  10332b:	89 c7                	mov    %eax,%edi
  10332d:	eb b2                	jmp    1032e1 <vsprintf+0x1a1>
    switch (*fmt)
  10332f:	89 c3                	mov    %eax,%ebx
        s = va_arg(args, char *);
  103331:	8b 45 10             	mov    0x10(%ebp),%eax
  103334:	83 c0 04             	add    $0x4,%eax
  103337:	89 45 b8             	mov    %eax,-0x48(%ebp)
  10333a:	8b 45 10             	mov    0x10(%ebp),%eax
  10333d:	8b 00                	mov    (%eax),%eax
  10333f:	89 45 bc             	mov    %eax,-0x44(%ebp)
        if (!s)
  103342:	85 c0                	test   %eax,%eax
  103344:	74 53                	je     103399 <vsprintf+0x259>
        len = strnlen(s, precision);
  103346:	83 ec 08             	sub    $0x8,%esp
  103349:	ff 75 c0             	push   -0x40(%ebp)
  10334c:	ff 75 bc             	push   -0x44(%ebp)
  10334f:	e8 2f 05 00 00       	call   103883 <strnlen>
        if (!(flags & LEFT))
  103354:	83 c4 10             	add    $0x10,%esp
  103357:	f6 45 c4 10          	testb  $0x10,-0x3c(%ebp)
  10335b:	74 45                	je     1033a2 <vsprintf+0x262>
        for (i = 0; i < len; ++i)
  10335d:	85 c0                	test   %eax,%eax
  10335f:	7e 6a                	jle    1033cb <vsprintf+0x28b>
  103361:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  103364:	8d 14 06             	lea    (%esi,%eax,1),%edx
  103367:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          *str++ = *s++;
  10336a:	46                   	inc    %esi
  10336b:	8a 01                	mov    (%ecx),%al
  10336d:	88 46 ff             	mov    %al,-0x1(%esi)
        for (i = 0; i < len; ++i)
  103370:	41                   	inc    %ecx
  103371:	39 d6                	cmp    %edx,%esi
  103373:	75 f5                	jne    10336a <vsprintf+0x22a>
  103375:	8b 45 c4             	mov    -0x3c(%ebp),%eax
        while (len < field_width--)
  103378:	39 c7                	cmp    %eax,%edi
  10337a:	0f 8e d1 03 00 00    	jle    103751 <vsprintf+0x611>
  103380:	29 c7                	sub    %eax,%edi
  103382:	8d 34 3a             	lea    (%edx,%edi,1),%esi
          *str++ = ' ';
  103385:	42                   	inc    %edx
  103386:	c6 42 ff 20          	movb   $0x20,-0x1(%edx)
        while (len < field_width--)
  10338a:	39 d6                	cmp    %edx,%esi
  10338c:	75 f7                	jne    103385 <vsprintf+0x245>
        s = va_arg(args, char *);
  10338e:	8b 45 b8             	mov    -0x48(%ebp),%eax
  103391:	89 45 10             	mov    %eax,0x10(%ebp)
  103394:	e9 86 03 00 00       	jmp    10371f <vsprintf+0x5df>
          s = "<NULL>";
  103399:	c7 45 bc 09 43 10 00 	movl   $0x104309,-0x44(%ebp)
  1033a0:	eb a4                	jmp    103346 <vsprintf+0x206>
          while (len < field_width--)
  1033a2:	8d 4f ff             	lea    -0x1(%edi),%ecx
  1033a5:	39 c7                	cmp    %eax,%edi
  1033a7:	7e 1e                	jle    1033c7 <vsprintf+0x287>
  1033a9:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  1033ac:	29 c7                	sub    %eax,%edi
  1033ae:	89 fa                	mov    %edi,%edx
  1033b0:	01 f2                	add    %esi,%edx
            *str++ = ' ';
  1033b2:	46                   	inc    %esi
  1033b3:	c6 46 ff 20          	movb   $0x20,-0x1(%esi)
          while (len < field_width--)
  1033b7:	39 d6                	cmp    %edx,%esi
  1033b9:	75 f7                	jne    1033b2 <vsprintf+0x272>
  1033bb:	89 c6                	mov    %eax,%esi
  1033bd:	2b 75 c4             	sub    -0x3c(%ebp),%esi
  1033c0:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
            *str++ = ' ';
  1033c3:	89 d6                	mov    %edx,%esi
  1033c5:	eb 96                	jmp    10335d <vsprintf+0x21d>
          while (len < field_width--)
  1033c7:	89 cf                	mov    %ecx,%edi
  1033c9:	eb 92                	jmp    10335d <vsprintf+0x21d>
        for (i = 0; i < len; ++i)
  1033cb:	89 f2                	mov    %esi,%edx
  1033cd:	eb a9                	jmp    103378 <vsprintf+0x238>
    switch (*fmt)
  1033cf:	89 c3                	mov    %eax,%ebx
        if (field_width == -1)
  1033d1:	83 ff ff             	cmp    $0xffffffff,%edi
  1033d4:	74 34                	je     10340a <vsprintf+0x2ca>
               (unsigned long)va_arg(args, void *),
  1033d6:	8b 45 10             	mov    0x10(%ebp),%eax
  1033d9:	83 c0 04             	add    $0x4,%eax
  1033dc:	89 45 bc             	mov    %eax,-0x44(%ebp)
        str = number(str,
  1033df:	83 ec 04             	sub    $0x4,%esp
  1033e2:	ff 75 c4             	push   -0x3c(%ebp)
  1033e5:	ff 75 c0             	push   -0x40(%ebp)
  1033e8:	57                   	push   %edi
  1033e9:	b9 10 00 00 00       	mov    $0x10,%ecx
  1033ee:	8b 7d 10             	mov    0x10(%ebp),%edi
  1033f1:	8b 17                	mov    (%edi),%edx
  1033f3:	89 f0                	mov    %esi,%eax
  1033f5:	e8 2d fb ff ff       	call   102f27 <number>
  1033fa:	89 c6                	mov    %eax,%esi
        continue;
  1033fc:	83 c4 10             	add    $0x10,%esp
               (unsigned long)va_arg(args, void *),
  1033ff:	8b 45 bc             	mov    -0x44(%ebp),%eax
  103402:	89 45 10             	mov    %eax,0x10(%ebp)
        continue;
  103405:	e9 15 03 00 00       	jmp    10371f <vsprintf+0x5df>
          flags |= ZEROPAD;
  10340a:	83 4d c4 01          	orl    $0x1,-0x3c(%ebp)
          field_width = 2 * sizeof(void *);
  10340e:	bf 08 00 00 00       	mov    $0x8,%edi
  103413:	eb c1                	jmp    1033d6 <vsprintf+0x296>
    switch (*fmt)
  103415:	89 c3                	mov    %eax,%ebx
  103417:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
        flags |= UPPERCASE;
  10341c:	83 4d c4 40          	orl    $0x40,-0x3c(%ebp)
        if (qualifier == 'l')
  103420:	83 f9 6c             	cmp    $0x6c,%ecx
  103423:	74 2a                	je     10344f <vsprintf+0x30f>
          str = iaddr(str,
  103425:	8b 45 10             	mov    0x10(%ebp),%eax
  103428:	83 c0 04             	add    $0x4,%eax
  10342b:	89 45 b8             	mov    %eax,-0x48(%ebp)
  10342e:	8b 45 10             	mov    0x10(%ebp),%eax
  103431:	8b 00                	mov    (%eax),%eax
  103433:	89 45 bc             	mov    %eax,-0x44(%ebp)
  for (i = 0; i < 4; i++)
  103436:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  len = 0;
  10343d:	b8 00 00 00 00       	mov    $0x0,%eax
  103442:	89 5d b4             	mov    %ebx,-0x4c(%ebp)
  103445:	89 75 b0             	mov    %esi,-0x50(%ebp)
  103448:	89 c3                	mov    %eax,%ebx
  10344a:	e9 76 01 00 00       	jmp    1035c5 <vsprintf+0x485>
          str = eaddr(str,
  10344f:	8b 45 10             	mov    0x10(%ebp),%eax
  103452:	83 c0 04             	add    $0x4,%eax
  103455:	89 45 bc             	mov    %eax,-0x44(%ebp)
  103458:	8b 45 10             	mov    0x10(%ebp),%eax
  10345b:	8b 00                	mov    (%eax),%eax
  10345d:	89 45 c0             	mov    %eax,-0x40(%ebp)
  if (type & UPPERCASE)
  103460:	f6 45 c4 40          	testb  $0x40,-0x3c(%ebp)
  103464:	74 1b                	je     103481 <vsprintf+0x341>
    dig = upper_digits;
  103466:	b8 e4 42 10 00       	mov    $0x1042e4,%eax
  for (i = 0; i < 6; i++)
  10346b:	b9 00 00 00 00       	mov    $0x0,%ecx
  len = 0;
  103470:	ba 00 00 00 00       	mov    $0x0,%edx
  103475:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  103478:	89 cb                	mov    %ecx,%ebx
  10347a:	89 75 b4             	mov    %esi,-0x4c(%ebp)
  10347d:	89 d6                	mov    %edx,%esi
  10347f:	eb 09                	jmp    10348a <vsprintf+0x34a>
  char *dig = digits;
  103481:	b8 bc 42 10 00       	mov    $0x1042bc,%eax
  103486:	eb e3                	jmp    10346b <vsprintf+0x32b>
    tmp[len++] = dig[addr[i] & 0x0F];
  103488:	89 ce                	mov    %ecx,%esi
    tmp[len++] = dig[addr[i] >> 4];
  10348a:	8b 55 c0             	mov    -0x40(%ebp),%edx
  10348d:	8a 14 1a             	mov    (%edx,%ebx,1),%dl
  103490:	88 d1                	mov    %dl,%cl
  103492:	c0 e9 04             	shr    $0x4,%cl
  103495:	0f b6 c9             	movzbl %cl,%ecx
  103498:	8a 0c 08             	mov    (%eax,%ecx,1),%cl
  10349b:	88 4c 35 d0          	mov    %cl,-0x30(%ebp,%esi,1)
    tmp[len++] = dig[addr[i] & 0x0F];
  10349f:	8d 4e 02             	lea    0x2(%esi),%ecx
  1034a2:	83 e2 0f             	and    $0xf,%edx
  1034a5:	8a 14 10             	mov    (%eax,%edx,1),%dl
  1034a8:	88 54 35 d1          	mov    %dl,-0x2f(%ebp,%esi,1)
  for (i = 0; i < 6; i++)
  1034ac:	43                   	inc    %ebx
  1034ad:	83 fb 06             	cmp    $0x6,%ebx
  1034b0:	74 0e                	je     1034c0 <vsprintf+0x380>
    if (i != 0)
  1034b2:	85 db                	test   %ebx,%ebx
  1034b4:	74 d2                	je     103488 <vsprintf+0x348>
      tmp[len++] = ':';
  1034b6:	83 c6 03             	add    $0x3,%esi
  1034b9:	c6 44 0d d0 3a       	movb   $0x3a,-0x30(%ebp,%ecx,1)
  1034be:	eb ca                	jmp    10348a <vsprintf+0x34a>
  if (!(type & LEFT))
  1034c0:	8b 5d b8             	mov    -0x48(%ebp),%ebx
  1034c3:	8b 75 b4             	mov    -0x4c(%ebp),%esi
  1034c6:	f6 45 c4 10          	testb  $0x10,-0x3c(%ebp)
  1034ca:	75 23                	jne    1034ef <vsprintf+0x3af>
    while (len < size--)
  1034cc:	8d 57 ff             	lea    -0x1(%edi),%edx
  1034cf:	39 cf                	cmp    %ecx,%edi
  1034d1:	7e 51                	jle    103524 <vsprintf+0x3e4>
  1034d3:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  1034d6:	89 f8                	mov    %edi,%eax
  1034d8:	29 c8                	sub    %ecx,%eax
  1034da:	01 f0                	add    %esi,%eax
      *str++ = ' ';
  1034dc:	46                   	inc    %esi
  1034dd:	c6 46 ff 20          	movb   $0x20,-0x1(%esi)
    while (len < size--)
  1034e1:	39 f0                	cmp    %esi,%eax
  1034e3:	75 f7                	jne    1034dc <vsprintf+0x39c>
  1034e5:	89 ce                	mov    %ecx,%esi
  1034e7:	2b 75 c4             	sub    -0x3c(%ebp),%esi
  1034ea:	8d 3c 16             	lea    (%esi,%edx,1),%edi
      *str++ = ' ';
  1034ed:	89 c6                	mov    %eax,%esi
  for (i = 0; i < len; ++i)
  1034ef:	85 c9                	test   %ecx,%ecx
  1034f1:	7e 35                	jle    103528 <vsprintf+0x3e8>
  1034f3:	b8 00 00 00 00       	mov    $0x0,%eax
    *str++ = tmp[i];
  1034f8:	8a 54 05 d0          	mov    -0x30(%ebp,%eax,1),%dl
  1034fc:	88 14 06             	mov    %dl,(%esi,%eax,1)
  for (i = 0; i < len; ++i)
  1034ff:	40                   	inc    %eax
  103500:	39 c1                	cmp    %eax,%ecx
  103502:	75 f4                	jne    1034f8 <vsprintf+0x3b8>
    *str++ = tmp[i];
  103504:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
  while (len < size--)
  103507:	39 f9                	cmp    %edi,%ecx
  103509:	7d 21                	jge    10352c <vsprintf+0x3ec>
  10350b:	29 cf                	sub    %ecx,%edi
  10350d:	8d 34 38             	lea    (%eax,%edi,1),%esi
    *str++ = ' ';
  103510:	40                   	inc    %eax
  103511:	c6 40 ff 20          	movb   $0x20,-0x1(%eax)
  while (len < size--)
  103515:	39 f0                	cmp    %esi,%eax
  103517:	75 f7                	jne    103510 <vsprintf+0x3d0>
          str = eaddr(str,
  103519:	8b 45 bc             	mov    -0x44(%ebp),%eax
  10351c:	89 45 10             	mov    %eax,0x10(%ebp)
  10351f:	e9 fb 01 00 00       	jmp    10371f <vsprintf+0x5df>
    while (len < size--)
  103524:	89 d7                	mov    %edx,%edi
  103526:	eb c7                	jmp    1034ef <vsprintf+0x3af>
  for (i = 0; i < len; ++i)
  103528:	89 f0                	mov    %esi,%eax
  10352a:	eb db                	jmp    103507 <vsprintf+0x3c7>
  while (len < size--)
  10352c:	89 c6                	mov    %eax,%esi
  10352e:	eb e9                	jmp    103519 <vsprintf+0x3d9>
    switch (*fmt)
  103530:	89 c3                	mov    %eax,%ebx
  103532:	e9 ee fe ff ff       	jmp    103425 <vsprintf+0x2e5>
  103537:	89 c3                	mov    %eax,%ebx
  103539:	e9 87 00 00 00       	jmp    1035c5 <vsprintf+0x485>
      if (n >= 100)
  10353e:	83 f9 63             	cmp    $0x63,%ecx
  103541:	0f 8e 9a 00 00 00    	jle    1035e1 <vsprintf+0x4a1>
        tmp[len++] = digits[n / 100];
  103547:	8d 43 01             	lea    0x1(%ebx),%eax
  10354a:	89 c6                	mov    %eax,%esi
  10354c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
  103551:	f7 e9                	imul   %ecx
  103553:	89 d0                	mov    %edx,%eax
  103555:	c1 f8 05             	sar    $0x5,%eax
  103558:	89 ca                	mov    %ecx,%edx
  10355a:	c1 fa 1f             	sar    $0x1f,%edx
  10355d:	29 d0                	sub    %edx,%eax
  10355f:	8a 90 bc 42 10 00    	mov    0x1042bc(%eax),%dl
  103565:	88 54 1d d0          	mov    %dl,-0x30(%ebp,%ebx,1)
        n          = n % 100;
  103569:	8d 04 80             	lea    (%eax,%eax,4),%eax
  10356c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  10356f:	c1 e0 02             	shl    $0x2,%eax
  103572:	29 c1                	sub    %eax,%ecx
        tmp[len++] = digits[n / 10];
  103574:	83 c3 02             	add    $0x2,%ebx
  103577:	b8 67 66 66 66       	mov    $0x66666667,%eax
  10357c:	f7 e9                	imul   %ecx
  10357e:	89 d0                	mov    %edx,%eax
  103580:	c1 f8 02             	sar    $0x2,%eax
  103583:	89 ca                	mov    %ecx,%edx
  103585:	c1 fa 1f             	sar    $0x1f,%edx
  103588:	29 d0                	sub    %edx,%eax
  10358a:	8a 90 bc 42 10 00    	mov    0x1042bc(%eax),%dl
  103590:	88 54 35 d0          	mov    %dl,-0x30(%ebp,%esi,1)
        n          = n % 10;
  103594:	8d 04 80             	lea    (%eax,%eax,4),%eax
  103597:	01 c0                	add    %eax,%eax
  103599:	29 c1                	sub    %eax,%ecx
      tmp[len++] = digits[n];
  10359b:	8d 43 01             	lea    0x1(%ebx),%eax
  10359e:	8a 91 bc 42 10 00    	mov    0x1042bc(%ecx),%dl
  1035a4:	88 54 1d d0          	mov    %dl,-0x30(%ebp,%ebx,1)
  for (i = 0; i < 4; i++)
  1035a8:	ff 45 c0             	incl   -0x40(%ebp)
  1035ab:	8b 5d c0             	mov    -0x40(%ebp),%ebx
  1035ae:	83 fb 04             	cmp    $0x4,%ebx
  1035b1:	74 5c                	je     10360f <vsprintf+0x4cf>
    if (i != 0)
  1035b3:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  1035b7:	0f 84 7a ff ff ff    	je     103537 <vsprintf+0x3f7>
      tmp[len++] = '.';
  1035bd:	8d 58 01             	lea    0x1(%eax),%ebx
  1035c0:	c6 44 05 d0 2e       	movb   $0x2e,-0x30(%ebp,%eax,1)
    n = addr[i];
  1035c5:	8b 45 bc             	mov    -0x44(%ebp),%eax
  1035c8:	8b 55 c0             	mov    -0x40(%ebp),%edx
  1035cb:	0f b6 0c 10          	movzbl (%eax,%edx,1),%ecx
    if (n == 0)
  1035cf:	85 c9                	test   %ecx,%ecx
  1035d1:	0f 85 67 ff ff ff    	jne    10353e <vsprintf+0x3fe>
      tmp[len++] = digits[0];
  1035d7:	8d 43 01             	lea    0x1(%ebx),%eax
  1035da:	c6 44 1d d0 30       	movb   $0x30,-0x30(%ebp,%ebx,1)
  1035df:	eb c7                	jmp    1035a8 <vsprintf+0x468>
      else if (n >= 10)
  1035e1:	83 f9 09             	cmp    $0x9,%ecx
  1035e4:	7e b5                	jle    10359b <vsprintf+0x45b>
        tmp[len++] = digits[n / 10];
  1035e6:	b8 67 66 66 66       	mov    $0x66666667,%eax
  1035eb:	f7 e9                	imul   %ecx
  1035ed:	89 d0                	mov    %edx,%eax
  1035ef:	c1 f8 02             	sar    $0x2,%eax
  1035f2:	89 ca                	mov    %ecx,%edx
  1035f4:	c1 fa 1f             	sar    $0x1f,%edx
  1035f7:	29 d0                	sub    %edx,%eax
  1035f9:	8a 90 bc 42 10 00    	mov    0x1042bc(%eax),%dl
  1035ff:	88 54 1d d0          	mov    %dl,-0x30(%ebp,%ebx,1)
        n          = n % 10;
  103603:	8d 04 80             	lea    (%eax,%eax,4),%eax
  103606:	01 c0                	add    %eax,%eax
  103608:	29 c1                	sub    %eax,%ecx
        tmp[len++] = digits[n / 10];
  10360a:	8d 5b 01             	lea    0x1(%ebx),%ebx
  10360d:	eb 8c                	jmp    10359b <vsprintf+0x45b>
  if (!(type & LEFT))
  10360f:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
  103612:	8b 75 b0             	mov    -0x50(%ebp),%esi
  103615:	f6 45 c4 10          	testb  $0x10,-0x3c(%ebp)
  103619:	75 27                	jne    103642 <vsprintf+0x502>
    while (len < size--)
  10361b:	8d 4f ff             	lea    -0x1(%edi),%ecx
  10361e:	39 c7                	cmp    %eax,%edi
  103620:	7e 55                	jle    103677 <vsprintf+0x537>
  103622:	89 7d c0             	mov    %edi,-0x40(%ebp)
  103625:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  103628:	29 c7                	sub    %eax,%edi
  10362a:	89 fa                	mov    %edi,%edx
  10362c:	01 f2                	add    %esi,%edx
      *str++ = ' ';
  10362e:	46                   	inc    %esi
  10362f:	c6 46 ff 20          	movb   $0x20,-0x1(%esi)
    while (len < size--)
  103633:	39 d6                	cmp    %edx,%esi
  103635:	75 f7                	jne    10362e <vsprintf+0x4ee>
  103637:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  10363a:	2b 75 c0             	sub    -0x40(%ebp),%esi
  10363d:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
      *str++ = ' ';
  103640:	89 d6                	mov    %edx,%esi
  for (i = 0; i < len; ++i)
  103642:	85 c0                	test   %eax,%eax
  103644:	7e 35                	jle    10367b <vsprintf+0x53b>
  103646:	ba 00 00 00 00       	mov    $0x0,%edx
    *str++ = tmp[i];
  10364b:	8a 4c 15 d0          	mov    -0x30(%ebp,%edx,1),%cl
  10364f:	88 0c 16             	mov    %cl,(%esi,%edx,1)
  for (i = 0; i < len; ++i)
  103652:	42                   	inc    %edx
  103653:	39 c2                	cmp    %eax,%edx
  103655:	75 f4                	jne    10364b <vsprintf+0x50b>
    *str++ = tmp[i];
  103657:	8d 14 06             	lea    (%esi,%eax,1),%edx
  while (len < size--)
  10365a:	39 f8                	cmp    %edi,%eax
  10365c:	7d 21                	jge    10367f <vsprintf+0x53f>
  10365e:	29 c7                	sub    %eax,%edi
  103660:	8d 34 3a             	lea    (%edx,%edi,1),%esi
    *str++ = ' ';
  103663:	42                   	inc    %edx
  103664:	c6 42 ff 20          	movb   $0x20,-0x1(%edx)
  while (len < size--)
  103668:	39 d6                	cmp    %edx,%esi
  10366a:	75 f7                	jne    103663 <vsprintf+0x523>
          str = iaddr(str,
  10366c:	8b 45 b8             	mov    -0x48(%ebp),%eax
  10366f:	89 45 10             	mov    %eax,0x10(%ebp)
  103672:	e9 a8 00 00 00       	jmp    10371f <vsprintf+0x5df>
    while (len < size--)
  103677:	89 cf                	mov    %ecx,%edi
  103679:	eb c7                	jmp    103642 <vsprintf+0x502>
  for (i = 0; i < len; ++i)
  10367b:	89 f2                	mov    %esi,%edx
  10367d:	eb db                	jmp    10365a <vsprintf+0x51a>
  while (len < size--)
  10367f:	89 d6                	mov    %edx,%esi
  103681:	eb e9                	jmp    10366c <vsprintf+0x52c>
    switch (*fmt)
  103683:	89 c3                	mov    %eax,%ebx
  103685:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
        base = 8;
  10368a:	b8 08 00 00 00       	mov    $0x8,%eax
        break;
  10368f:	e9 1d fc ff ff       	jmp    1032b1 <vsprintf+0x171>
    switch (*fmt)
  103694:	89 c3                	mov    %eax,%ebx
  103696:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
        flags |= UPPERCASE;
  10369b:	83 4d c4 40          	orl    $0x40,-0x3c(%ebp)
        base = 16;
  10369f:	b8 10 00 00 00       	mov    $0x10,%eax
  1036a4:	e9 08 fc ff ff       	jmp    1032b1 <vsprintf+0x171>
    switch (*fmt)
  1036a9:	89 c3                	mov    %eax,%ebx
  1036ab:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
        flags |= SIGN;
  1036b0:	83 4d c4 02          	orl    $0x2,-0x3c(%ebp)
    base = 10;
  1036b4:	b8 0a 00 00 00       	mov    $0xa,%eax
  1036b9:	e9 f3 fb ff ff       	jmp    1032b1 <vsprintf+0x171>
    switch (*fmt)
  1036be:	89 c3                	mov    %eax,%ebx
        if (*fmt != '%')
  1036c0:	80 fa 25             	cmp    $0x25,%dl
  1036c3:	0f 84 a9 00 00 00    	je     103772 <vsprintf+0x632>
          *str++ = '%';
  1036c9:	8d 46 01             	lea    0x1(%esi),%eax
  1036cc:	c6 06 25             	movb   $0x25,(%esi)
        if (*fmt)
  1036cf:	8a 13                	mov    (%ebx),%dl
  1036d1:	84 d2                	test   %dl,%dl
  1036d3:	0f 85 9d 00 00 00    	jne    103776 <vsprintf+0x636>
          --fmt;
  1036d9:	4b                   	dec    %ebx
          *str++ = '%';
  1036da:	89 c6                	mov    %eax,%esi
  1036dc:	eb 41                	jmp    10371f <vsprintf+0x5df>
    switch (*fmt)
  1036de:	b8 0a 00 00 00       	mov    $0xa,%eax
  1036e3:	e9 c9 fb ff ff       	jmp    1032b1 <vsprintf+0x171>
  1036e8:	89 c3                	mov    %eax,%ebx
  1036ea:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  1036ef:	b8 0a 00 00 00       	mov    $0xa,%eax
  1036f4:	e9 b8 fb ff ff       	jmp    1032b1 <vsprintf+0x171>
      num = va_arg(args, unsigned long);
  1036f9:	8b 55 10             	mov    0x10(%ebp),%edx
  1036fc:	8b 12                	mov    (%edx),%edx
  1036fe:	8b 4d 10             	mov    0x10(%ebp),%ecx
  103701:	8d 49 04             	lea    0x4(%ecx),%ecx
  103704:	89 4d 10             	mov    %ecx,0x10(%ebp)
    else
      num = va_arg(args, unsigned int);

    str = number(str, num, base, field_width, precision, flags);
  103707:	83 ec 04             	sub    $0x4,%esp
  10370a:	ff 75 c4             	push   -0x3c(%ebp)
  10370d:	ff 75 c0             	push   -0x40(%ebp)
  103710:	57                   	push   %edi
  103711:	89 c1                	mov    %eax,%ecx
  103713:	89 f0                	mov    %esi,%eax
  103715:	e8 0d f8 ff ff       	call   102f27 <number>
  10371a:	89 c6                	mov    %eax,%esi
  10371c:	83 c4 10             	add    $0x10,%esp
  for (str = buf; *fmt; fmt++)
  10371f:	8d 4b 01             	lea    0x1(%ebx),%ecx
  103722:	8a 43 01             	mov    0x1(%ebx),%al
  103725:	84 c0                	test   %al,%al
  103727:	74 32                	je     10375b <vsprintf+0x61b>
    if (*fmt != '%')
  103729:	3c 25                	cmp    $0x25,%al
  10372b:	0f 84 2f fa ff ff    	je     103160 <vsprintf+0x20>
      *str++ = *fmt;
  103731:	88 06                	mov    %al,(%esi)
      continue;
  103733:	89 cb                	mov    %ecx,%ebx
      *str++ = *fmt;
  103735:	8d 76 01             	lea    0x1(%esi),%esi
      continue;
  103738:	eb e5                	jmp    10371f <vsprintf+0x5df>
      num = va_arg(args, unsigned int);
  10373a:	8b 55 10             	mov    0x10(%ebp),%edx
  10373d:	8b 12                	mov    (%edx),%edx
  10373f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  103742:	8d 49 04             	lea    0x4(%ecx),%ecx
  103745:	89 4d 10             	mov    %ecx,0x10(%ebp)
  103748:	eb bd                	jmp    103707 <vsprintf+0x5c7>
        *str++ = (unsigned char)va_arg(args, int);
  10374a:	89 55 10             	mov    %edx,0x10(%ebp)
  10374d:	89 c6                	mov    %eax,%esi
  10374f:	eb ce                	jmp    10371f <vsprintf+0x5df>
        s = va_arg(args, char *);
  103751:	8b 45 b8             	mov    -0x48(%ebp),%eax
  103754:	89 45 10             	mov    %eax,0x10(%ebp)
        while (len < field_width--)
  103757:	89 d6                	mov    %edx,%esi
  103759:	eb c4                	jmp    10371f <vsprintf+0x5df>
  10375b:	89 f3                	mov    %esi,%ebx
  }

  *str = '\0';
  10375d:	c6 03 00             	movb   $0x0,(%ebx)
  return str - buf;
  103760:	89 d8                	mov    %ebx,%eax
  103762:	2b 45 08             	sub    0x8(%ebp),%eax
}
  103765:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103768:	5b                   	pop    %ebx
  103769:	5e                   	pop    %esi
  10376a:	5f                   	pop    %edi
  10376b:	5d                   	pop    %ebp
  10376c:	c3                   	ret    
  for (str = buf; *fmt; fmt++)
  10376d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  103770:	eb eb                	jmp    10375d <vsprintf+0x61d>
        if (*fmt)
  103772:	8a 13                	mov    (%ebx),%dl
  103774:	89 f0                	mov    %esi,%eax
          *str++ = *fmt;
  103776:	8d 70 01             	lea    0x1(%eax),%esi
  103779:	88 10                	mov    %dl,(%eax)
  10377b:	eb a2                	jmp    10371f <vsprintf+0x5df>

0010377d <sprintf>:

int sprintf(char *str, const char *fmt, ...) {
  10377d:	55                   	push   %ebp
  10377e:	89 e5                	mov    %esp,%ebp
  103780:	83 ec 0c             	sub    $0xc,%esp
  int r;
  va_list args;
  va_start(args, fmt);
  103783:	8d 45 10             	lea    0x10(%ebp),%eax
  r = vsprintf(str, fmt, args);
  103786:	50                   	push   %eax
  103787:	ff 75 0c             	push   0xc(%ebp)
  10378a:	ff 75 08             	push   0x8(%ebp)
  10378d:	e8 ae f9 ff ff       	call   103140 <vsprintf>
  va_end(args);
  return r;
}
  103792:	c9                   	leave  
  103793:	c3                   	ret    

00103794 <vcprintf>:

int vcprintf(void (*putstr)(const char*), const char *format, va_list args) {
  103794:	55                   	push   %ebp
  103795:	89 e5                	mov    %esp,%ebp
  103797:	56                   	push   %esi
  103798:	53                   	push   %ebx
  103799:	81 ec 04 02 00 00    	sub    $0x204,%esp
  int r;
  char buf[512];
  r = vsprintf(buf, format, args);
  10379f:	ff 75 10             	push   0x10(%ebp)
  1037a2:	ff 75 0c             	push   0xc(%ebp)
  1037a5:	8d b5 f8 fd ff ff    	lea    -0x208(%ebp),%esi
  1037ab:	56                   	push   %esi
  1037ac:	e8 8f f9 ff ff       	call   103140 <vsprintf>
  1037b1:	89 c3                	mov    %eax,%ebx
  putstr(buf);
  1037b3:	89 34 24             	mov    %esi,(%esp)
  1037b6:	ff 55 08             	call   *0x8(%ebp)
  return r;
}
  1037b9:	89 d8                	mov    %ebx,%eax
  1037bb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1037be:	5b                   	pop    %ebx
  1037bf:	5e                   	pop    %esi
  1037c0:	5d                   	pop    %ebp
  1037c1:	c3                   	ret    

001037c2 <cprintf>:

int cprintf(void (*putstr)(const char*), const char *format, ...) {
  1037c2:	55                   	push   %ebp
  1037c3:	89 e5                	mov    %esp,%ebp
  1037c5:	83 ec 0c             	sub    $0xc,%esp
  int r;
  va_list args;
  va_start(args, format);
  1037c8:	8d 45 10             	lea    0x10(%ebp),%eax
  r = vcprintf(putstr, format, args);
  1037cb:	50                   	push   %eax
  1037cc:	ff 75 0c             	push   0xc(%ebp)
  1037cf:	ff 75 08             	push   0x8(%ebp)
  1037d2:	e8 bd ff ff ff       	call   103794 <vcprintf>
  va_end(args);
  return r;
}
  1037d7:	c9                   	leave  
  1037d8:	c3                   	ret    

001037d9 <strcmp>:
#include "lib.h"

int
strcmp (const char *s1,
      const char *s2)
{
  1037d9:	55                   	push   %ebp
  1037da:	89 e5                	mov    %esp,%ebp
  1037dc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1037df:	8b 55 0c             	mov    0xc(%ebp),%edx
  while (*s1 != '\0' && *s1 == *s2)
  1037e2:	8a 01                	mov    (%ecx),%al
  1037e4:	84 c0                	test   %al,%al
  1037e6:	74 0c                	je     1037f4 <strcmp+0x1b>
  1037e8:	38 02                	cmp    %al,(%edx)
  1037ea:	75 08                	jne    1037f4 <strcmp+0x1b>
    {
      s1++;
  1037ec:	41                   	inc    %ecx
      s2++;
  1037ed:	42                   	inc    %edx
  while (*s1 != '\0' && *s1 == *s2)
  1037ee:	8a 01                	mov    (%ecx),%al
  1037f0:	84 c0                	test   %al,%al
  1037f2:	75 f4                	jne    1037e8 <strcmp+0xf>
    }

  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
  1037f4:	0f b6 c0             	movzbl %al,%eax
  1037f7:	0f b6 12             	movzbl (%edx),%edx
  1037fa:	29 d0                	sub    %edx,%eax
}
  1037fc:	5d                   	pop    %ebp
  1037fd:	c3                   	ret    

001037fe <memset>:

void *
memset (void *m,
      int c,
      size_t n)
{
  1037fe:	55                   	push   %ebp
  1037ff:	89 e5                	mov    %esp,%ebp
  103801:	53                   	push   %ebx
  103802:	8b 45 08             	mov    0x8(%ebp),%eax
  103805:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  103808:	8b 4d 10             	mov    0x10(%ebp),%ecx
  char *s = (char *) m;

  while (n--)
  10380b:	85 c9                	test   %ecx,%ecx
  10380d:	74 0c                	je     10381b <memset+0x1d>
  10380f:	01 c1                	add    %eax,%ecx
  char *s = (char *) m;
  103811:	89 c2                	mov    %eax,%edx
    *s++ = (char) c;
  103813:	42                   	inc    %edx
  103814:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (n--)
  103817:	39 d1                	cmp    %edx,%ecx
  103819:	75 f8                	jne    103813 <memset+0x15>

  return m;
}
  10381b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10381e:	c9                   	leave  
  10381f:	c3                   	ret    

00103820 <strcpy>:
#include "lib.h"

char*
strcpy (char *dst0,
      const char *src0)
{
  103820:	55                   	push   %ebp
  103821:	89 e5                	mov    %esp,%ebp
  103823:	53                   	push   %ebx
  103824:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103827:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  char *s = dst0;

  while ((*dst0++ = *src0++))
  10382a:	b8 00 00 00 00       	mov    $0x0,%eax
  10382f:	8a 14 03             	mov    (%ebx,%eax,1),%dl
  103832:	88 14 01             	mov    %dl,(%ecx,%eax,1)
  103835:	40                   	inc    %eax
  103836:	84 d2                	test   %dl,%dl
  103838:	75 f5                	jne    10382f <strcpy+0xf>
    ;

  return s;
}
  10383a:	89 c8                	mov    %ecx,%eax
  10383c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10383f:	c9                   	leave  
  103840:	c3                   	ret    

00103841 <memcpy>:

void *
memcpy (void *__restrict dst0,
      const void *__restrict src0,
      size_t len0)
{
  103841:	55                   	push   %ebp
  103842:	89 e5                	mov    %esp,%ebp
  103844:	56                   	push   %esi
  103845:	53                   	push   %ebx
  103846:	8b 45 08             	mov    0x8(%ebp),%eax
  103849:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10384c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  char *dst = (char *) dst0;
  char *src = (char *) src0;

  void *save = dst0;

  while (len0--)
  10384f:	85 db                	test   %ebx,%ebx
  103851:	74 11                	je     103864 <memcpy+0x23>
  103853:	8d 34 03             	lea    (%ebx,%eax,1),%esi
  char *dst = (char *) dst0;
  103856:	89 c2                	mov    %eax,%edx
    {
      *dst++ = *src++;
  103858:	41                   	inc    %ecx
  103859:	42                   	inc    %edx
  10385a:	8a 59 ff             	mov    -0x1(%ecx),%bl
  10385d:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (len0--)
  103860:	39 d6                	cmp    %edx,%esi
  103862:	75 f4                	jne    103858 <memcpy+0x17>
    }

  return save;
}
  103864:	5b                   	pop    %ebx
  103865:	5e                   	pop    %esi
  103866:	5d                   	pop    %ebp
  103867:	c3                   	ret    

00103868 <strlen>:
#include "lib.h"

size_t
strlen (const char *str)
{
  103868:	55                   	push   %ebp
  103869:	89 e5                	mov    %esp,%ebp
  10386b:	8b 55 08             	mov    0x8(%ebp),%edx
  const char *start = str;

  while (*str)
  10386e:	80 3a 00             	cmpb   $0x0,(%edx)
  103871:	74 0c                	je     10387f <strlen+0x17>
  103873:	89 d0                	mov    %edx,%eax
    str++;
  103875:	40                   	inc    %eax
  while (*str)
  103876:	80 38 00             	cmpb   $0x0,(%eax)
  103879:	75 fa                	jne    103875 <strlen+0xd>
  return str - start;
  10387b:	29 d0                	sub    %edx,%eax
}
  10387d:	5d                   	pop    %ebp
  10387e:	c3                   	ret    
  while (*str)
  10387f:	89 d0                	mov    %edx,%eax
  103881:	eb f8                	jmp    10387b <strlen+0x13>

00103883 <strnlen>:
#include "lib.h"

size_t
strnlen (const char *str,
	size_t n)
{
  103883:	55                   	push   %ebp
  103884:	89 e5                	mov    %esp,%ebp
  103886:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103889:	8b 55 0c             	mov    0xc(%ebp),%edx
  const char *start = str;

  while (n-- > 0 && *str)
  10388c:	85 d2                	test   %edx,%edx
  10388e:	74 14                	je     1038a4 <strnlen+0x21>
  103890:	01 ca                	add    %ecx,%edx
  103892:	89 c8                	mov    %ecx,%eax
  103894:	80 38 00             	cmpb   $0x0,(%eax)
  103897:	74 07                	je     1038a0 <strnlen+0x1d>
    str++;
  103899:	40                   	inc    %eax
  while (n-- > 0 && *str)
  10389a:	39 d0                	cmp    %edx,%eax
  10389c:	75 f6                	jne    103894 <strnlen+0x11>
    str++;
  10389e:	89 d0                	mov    %edx,%eax

  return str - start;
  1038a0:	29 c8                	sub    %ecx,%eax
}
  1038a2:	5d                   	pop    %ebp
  1038a3:	c3                   	ret    
  while (n-- > 0 && *str)
  1038a4:	89 c8                	mov    %ecx,%eax
  1038a6:	eb f8                	jmp    1038a0 <strnlen+0x1d>
